{"version":3,"sources":["/home/remynguyen/Desktop/angular4/minimal/node_modules/@ngrx/effects/@ngrx/effects.es5.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/@ngrx/store-devtools/@ngrx/store-devtools.es5.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/@ngrx/store/@ngrx/store.es5.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/css-loader/lib/css-base.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/ReplaySubject.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/add/operator/catch.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/add/operator/debounceTime.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/add/operator/distinctUntilChanged.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/add/operator/mergeMap.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/add/operator/switchMap.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/observable/empty.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/operator/dematerialize.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/operator/distinctUntilChanged.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/operator/exhaustMap.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/operator/groupBy.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/operator/ignoreElements.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/operator/materialize.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/operator/pluck.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/operator/scan.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/operator/skip.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/operator/withLatestFrom.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/scheduler/QueueAction.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/scheduler/QueueScheduler.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/scheduler/queue.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/util/FastMap.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/util/Map.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/util/MapPolyfill.js","/home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/util/noop.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AAC4D;AAC7C;AACS;AACH;AACR;AACmD;AAC5C;AACJ;AACC;AACC;AACE;AACG;AACN;AAClB;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,mBAAmB,EAAE;AACrB,mEAAmE,qEAAqE,EAAE;AAC1I;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA,kCAAkC,8BAA8B,EAAE;AAClE;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA,uBAAuB,EAAE;AACzB,uBAAuB,EAAE,gBAAgB;AACzC;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,mBAAmB,EAAE;AACrB,mBAAmB,EAAE;AACrB;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,mHAAgE;AAChE;AACA;AACA;AACA;AACA;AACA,SAAS,EAAE,EAAE;AACb,KAAK;AACL;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,gBAAgB;AAChB;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA,0GAAoD,2CAA2C,6BAA6B,EAAE,EAAE,EAAE;AAClI;AACA;AACA,CAAC;AACD;AACA,KAAK,0EAAmB;AACxB;AACA;AACA;AACA;AACA,sCAAsC;AACtC,KAAK,kFAAiC,2JAA+C,IAAI;AACzF,EAAE;AACF;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,4BAA4B,EAAE;AAC9B;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,KAAK,0EAAmB;AACxB;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,KAAK,gCAAgC,wFAAiC,IAAI;AAC1E,EAAE;AACF;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,0MAA2F;AAC3F;AACA;AACA,SAAS,4BAA4B,kCAAkC,EAAE,GAAG,EAAE;AAC9E;AACA;AACA,CAAC;AACD;AACA,KAAK,0EAAmB;AACxB;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,KAAK,uBAAuB;AAC5B,EAAE;AACF;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,KAAK,0EAAmB;AACxB;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,KAAK,uBAAuB;AAC5B,KAAK,oEAAe;AACpB,EAAE;AACF;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA,6DAA6D,iDAAiD,EAAE;AAChH;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,KAAK,iFAA0B,IAAI;AACnC;AACA;AACA;AACA;AACA,gDAAgD;AAChD,KAAK,uBAAuB;AAC5B,KAAK,uBAAuB;AAC5B,KAAK,4BAA4B,6FAAsC,IAAI;AAC3E,KAAK,uFAAkC,wEAAiB,IAAI;AAC5D,EAAE;AACF;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA,qDAAqD,uDAAuD,8CAA8C,EAAE,EAAE,EAAE;AAChK;AACA;AACA,CAAC;AACD;AACA,KAAK,iFAA0B,IAAI;AACnC;AACA;AACA;AACA;AACA,mDAAmD;AACnD,KAAK,2BAA2B;AAChC,KAAK,4BAA4B,gGAAyC,IAAI;AAC9E,KAAK,uFAAkC,wEAAiB,IAAI;AAC5D,EAAE;AACF;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,KAAK,iFAA0B,IAAI;AACnC;AACA;AACA;AACA;AACA,4CAA4C,WAAW;AACvD;AACA,WAAW,KAAK;AAChB,YAAY;AACZ;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACQ;AACR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvfA;AAAA;AAAA;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACsD;AACoF;AACnH;AACV;AACE;AACI;AACL;AACA;AACU;AACT;AACK;AACL;AACC;AACD;AACI;AACA;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,yCAAyC,iCAAiC,EAAE;AAC5E;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,kDAAkD,mBAAmB;AACrE;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA,aAAa;AACb,oDAAoD,gCAAgC,EAAE;AACtF;AACA,SAAS;AACT;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE,6GAAsD,mDAAmD,EAAE;AACpI;AACA,uBAAuB,EAAE,4GAAqD,kDAAkD,EAAE;AAClI;AACA,uBAAuB,EAAE;AACzB,+FAAwC,sDAAsD,EAAE;AAChG,wFAAqC,2CAA2C,EAAE;AAClF;AACA;AACA,uBAAuB,EAAE;AACzB,+FAAwC,oDAAoD,EAAE;AAC9F,wFAAqC,2CAA2C,EAAE;AAClF;AACA,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB;AACA,sHAA4D,0BAA0B,EAAE;AACxF,4HAAkE,yBAAyB,EAAE;AAC7F;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,KAAK,0EAAmB;AACxB;AACA;AACA;AACA;AACA,gDAAgD;AAChD,KAAK,gCAAgC,yGAAkD,IAAI;AAC3F,EAAE;AACF,mBAAmB;AACnB;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,wBAAwB,EAAE,iCAAiC,4BAA4B;AACvF,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA;AACA,kDAAkD;AAClD;AACA,sBAAsB,6BAA6B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,GAAG;AACd,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B,2BAA2B,EAAE;AAC7B,gCAAgC,EAAE,UAAU,wBAAwB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,uCAAuC,EAAE;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,EAAE;AACjC;AACA;AACA;AACA;AACA,8EAA8E,0BAA0B,EAAE;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,EAAE;AACjC,oCAAoC,EAAE,cAAc,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,EAAE;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,KAAK,0EAAmB;AACxB;AACA;AACA;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA,6GAA6G,wBAAwB,KAAK;AAC1I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,iBAAiB;AACjB,iBAAiB,0CAA0C;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA,sDAAsD;AACtD;AACA,gBAAgB;AAChB;AACA,oDAAoD;AACpD;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,KAAK,0EAAmB;AACxB;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,KAAK,4BAA4B;AACjC,KAAK,6EAAwB;AAC7B,KAAK,gFAA2B;AAChC,KAAK,2BAA2B;AAChC,KAAK,oFAA+B;AACpC,KAAK,gCAAgC,mJAAuC,IAAI;AAChF,KAAK,0CAA0C,sGAA+C,IAAI;AAClG,EAAE;AACF;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,mBAAmB,EAAE,6BAA6B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,KAAK,iFAA0B,IAAI;AACnC;AACA;AACA;AACA;AACA,kDAAkD,WAAW;AAC7D;AACA;AACA;AACQ;AACR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClxBA;AAAA;AAAA;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACgE;AACvC;AACL;AACH;AACF;AACI;AACK;AACV;AACD;AACE;AACe;AAC/B;AACA,WAAW,EAAE;AACb,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA,kCAAkC,mBAAmB;AACrD,mBAAmB,EAAE;AACrB,mBAAmB,EAAE;AACrB,wBAAwB,EAAE,UAAU,wBAAwB;AAC5D,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,+BAA+B,sBAAsB;AACrD,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB,4BAA4B,EAAE,UAAU,6BAA6B;AACrE,2BAA2B,EAAE;AAC7B,2BAA2B,EAAE;AAC7B,2BAA2B,EAAE;AAC7B,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA,gCAAgC,4BAA4B,EAAE;AAC9D;AACA,6CAA6C;AAC7C;AACA,KAAK,IAAI;AACT;AACA;AACA,WAAW,KAAK;AAChB,YAAY;AACZ;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB,yDAAyD,qBAAqB,EAAE;AAChF;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,aAAa;AAC/C;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,KAAK,0EAAmB;AACxB;AACA;AACA;AACA;AACA,6CAA6C,WAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,wCAAwC,yBAAyB;AACjE;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,8BAA8B,eAAe;AAC7C;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,KAAK,0EAAmB;AACxB;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,KAAK,kCAAkC;AACvC,KAAK,gCAAgC,8FAAuC,IAAI;AAChF,KAAK,gCAAgC,iGAA0C,IAAI;AACnF,KAAK,gCAAgC,gGAAyC,IAAI;AAClF,EAAE;AACF;AACA;AACA,KAAK,0DAA0D;AAC/D,KAAK,iEAAiE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,KAAK,0EAAmB;AACxB;AACA;AACA;AACA;AACA,oDAAoD,WAAW;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,KAAK,0EAAmB;AACxB;AACA;AACA;AACA;AACA,oCAAoC;AACpC,KAAK,wBAAwB;AAC7B,KAAK,2BAA2B;AAChC,KAAK,+BAA+B;AACpC,KAAK,gCAAgC,8FAAuC,IAAI;AAChF,EAAE;AACF;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA,qCAAqC,oBAAoB,oBAAoB;AAC7E;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,KAAK,+CAA+C;AACpD;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,KAAK;AACpB,gBAAgB;AAChB;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,KAAK,0EAAmB;AACxB;AACA;AACA;AACA;AACA,oCAAoC;AACpC,KAAK,yBAAyB;AAC9B,KAAK,wBAAwB;AAC7B,KAAK,wBAAwB;AAC7B,EAAE;AACF;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,KAAK,iFAA0B,IAAI;AACnC;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,KAAK,wBAAwB;AAC7B,KAAK,2BAA2B;AAChC,KAAK,+BAA+B;AACpC,EAAE;AACF;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,YAAY,+EAA+E;AAC9H,SAAS;AACT,yCAAyC,2CAA2C,EAAE;AACtF;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,kDAAkD,oDAAoD,EAAE;AACxG;AACA;AACA,CAAC;AACD;AACA,KAAK,iFAA0B,IAAI;AACnC;AACA;AACA;AACA;AACA,iDAAiD;AACjD,KAAK,4BAA4B,+FAAwC,IAAI;AAC7E,KAAK,4BAA4B,iGAA0C,IAAI;AAC/E,KAAK,wBAAwB;AAC7B,EAAE;AACF;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA,iBAAiB,yDAAyD;AAC1E;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB,iDAAiD;AAClE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,EAAE;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,iBAAiB,8DAA8D;AAC/E;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,KAAK,iFAA0B,IAAI;AACnC;AACA;AACA;AACA;AACA,0CAA0C,WAAW;AACrD;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,mBAAmB,EAAE;AACrB,mBAAmB,EAAE;AACrB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,EAAE,UAAU,sBAAsB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,WAAW,KAAK;AAChB,YAAY;AACZ;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA,mBAAmB,EAAE;AACrB,mBAAmB,EAAE;AACrB,mBAAmB,EAAE,8DAA8D,mEAAmE,EAAE;AACxJ,mBAAmB,EAAE;AACrB;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA,KAAK;AACL,mBAAmB,EAAE;AACrB,uBAAuB,EAAE,wCAAwC,kBAAkB,EAAE;AACrF;AACA,KAAK;AACL;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,uDAAuD,2BAA2B,EAAE;AACpF;AACA,kDAAkD,mBAAmB;AACrE;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA,KAAK;AACL,oCAAoC,iBAAiB;AACrD;AACA;AACA;AACA;AACQ;AACR;;;;;;;;AC3tBA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD,IAAI;AACJ;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oDAAoD,cAAc;;AAElE;AACA;;;;;;;;;AC3EA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uCAAuC;AAC3E,oCAAoC,uCAAuC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,yC;;;;;;;;ACrGA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;ACLA;AACA;AACA;AACA;AACA,wC;;;;;;;;ACJA;AACA;AACA;AACA;AACA,gD;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;ACLA;AACA;AACA;AACA;AACA,qC;;;;;;;;ACJA;AACA;AACA;AACA,iC;;;;;;;;ACHA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA,8BAA8B,mBAAmB;AACjD;AACA;AACA,mCAAmC,mBAAmB;AACtD,sDAAsD,kBAAkB;AACxE;AACA;AACA;AACA;AACA,IAAI,mBAAmB;AACvB;AACA;AACA;AACA;AACA,0CAA0C,kBAAkB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,yC;;;;;;;;AC1EA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qBAAqB;AAC7B,QAAQ,qBAAqB;AAC7B,QAAQ,qBAAqB;AAC7B,QAAQ,qBAAqB;AAC7B;AACA;AACA;AACA;AACA,OAAO;AACP,OAAO;AACP,OAAO;AACP;AACA,SAAS;AACT,SAAS;AACT;AACA,WAAW,SAAS;AACpB,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,gD;;;;;;;;AC3GA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,oDAAoD;AAC/D;AACA;AACA,WAAW,oFAAoF;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,sC;;;;;;;;ACzIA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wBAAwB;AAC5B;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C,uBAAuB,mBAAmB;AAC1C,uBAAuB,mBAAmB;AAC1C,uBAAuB,oBAAoB;AAC3C,uBAAuB,mBAAmB;AAC1C,uBAAuB,sBAAsB;AAC7C,uBAAuB,oBAAoB;AAC3C,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,sBAAsB;AAC/B,SAAS,sBAAsB;AAC/B,SAAS,qBAAqB;AAC9B;AACA,SAAS,qBAAqB;AAC9B,SAAS,qBAAqB;AAC9B,SAAS,wBAAwB;AACjC,SAAS,0BAA0B;AACnC;AACA,SAAS,sBAAsB;AAC/B;AACA;AACA,uBAAuB,oBAAoB;AAC3C,uBAAuB,mBAAmB;AAC1C,uBAAuB,mBAAmB;AAC1C,uBAAuB,oBAAoB;AAC3C,uBAAuB,mBAAmB;AAC1C,uBAAuB,sBAAsB;AAC7C,uBAAuB,oBAAoB;AAC3C,uBAAuB;AACvB;AACA;AACA;AACA,qBAAqB,+CAA+C;AACpE;AACA;AACA;AACA,OAAO;AACP,OAAO;AACP,OAAO;AACP;AACA,WAAW,sBAAsB;AACjC;AACA,WAAW,sBAAsB;AACjC;AACA,WAAW,2DAA2D;AACtE;AACA;AACA,YAAY,mCAAmC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,mC;;;;;;;;ACjRA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,0C;;;;;;;;AC9CA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA,IAAI,mBAAmB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,oBAAoB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;AACtB;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT;AACA,YAAY,4BAA4B;AACxC,IAAI,mBAAmB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,uC;;;;;;;;ACzFA;AACA;AACA;AACA;AACA;AACA,gCAAgC,UAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,WAAW,UAAU;AACrB;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;ACxDA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,aAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT,SAAS;AACT;AACA,WAAW,6CAA6C;AACxD;AACA,WAAW,IAAI;AACf,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,gC;;;;;;;;ACtHA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,gC;;;;;;;;AClDA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,WAAW,gBAAgB;AAC3B;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,0C;;;;;;;;ACjIA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,uC;;;;;;;;AChDA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,0C;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,YAAY;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,mC;;;;;;;;AC9BA;AACA;AACA;AACA,+CAA+C,kCAAkC,EAAE;AACnF,+B;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,uC;;;;;;;;AC9CA;AACA;AACA,iBAAiB;AACjB;AACA,gC","file":"common.chunk.js","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { ScannedActionsSubject, Store, StoreModule, compose } from '@ngrx/store';\nimport { merge } from 'rxjs/observable/merge';\nimport { ignoreElements } from 'rxjs/operator/ignoreElements';\nimport { materialize } from 'rxjs/operator/materialize';\nimport { map } from 'rxjs/operator/map';\nimport { Inject, Injectable, InjectionToken, NgModule, Optional } from '@angular/core';\nimport { Observable } from 'rxjs/Observable';\nimport { filter } from 'rxjs/operator/filter';\nimport { groupBy } from 'rxjs/operator/groupBy';\nimport { mergeMap } from 'rxjs/operator/mergeMap';\nimport { exhaustMap } from 'rxjs/operator/exhaustMap';\nimport { dematerialize } from 'rxjs/operator/dematerialize';\nimport { Subject } from 'rxjs/Subject';\nvar METADATA_KEY = '@ngrx/effects';\nvar r = Reflect;\n/**\n * @param {?} sourceType\n * @return {?}\n */\nfunction hasStaticMetadata(sourceType) {\n    return !!((sourceType)).propDecorators;\n}\n/**\n * @param {?} sourceType\n * @return {?}\n */\nfunction getStaticMetadata(sourceType) {\n    var /** @type {?} */ propDecorators = sourceType.propDecorators;\n    return Object.keys(propDecorators).reduce(function (all, key) { return all.concat(getStaticMetadataEntry(propDecorators[key], key)); }, []);\n}\n/**\n * @param {?} metadataEntry\n * @param {?} propertyName\n * @return {?}\n */\nfunction getStaticMetadataEntry(metadataEntry, propertyName) {\n    return metadataEntry\n        .filter(function (entry) { return entry.type === Effect; })\n        .map(function (entry) {\n        var /** @type {?} */ dispatch = true;\n        if (entry.args && entry.args.length) {\n            dispatch = !!entry.args[0].dispatch;\n        }\n        return { propertyName: propertyName, dispatch: dispatch };\n    });\n}\n/**\n * @param {?} sourceProto\n * @return {?}\n */\nfunction getEffectMetadataEntries(sourceProto) {\n    if (hasStaticMetadata(sourceProto.constructor)) {\n        return getStaticMetadata(sourceProto.constructor);\n    }\n    if (r.hasOwnMetadata(METADATA_KEY, sourceProto)) {\n        return r.getOwnMetadata(METADATA_KEY, sourceProto);\n    }\n    return [];\n}\n/**\n * @param {?} sourceProto\n * @param {?} entries\n * @return {?}\n */\nfunction setEffectMetadataEntries(sourceProto, entries) {\n    r.defineMetadata(METADATA_KEY, entries, sourceProto);\n}\n/**\n * \\@Annotation\n * @param {?=} __0\n * @return {?}\n */\nfunction Effect(_a) {\n    var dispatch = (_a === void 0 ? { dispatch: true } : _a).dispatch;\n    return function (target, propertyName) {\n        var /** @type {?} */ effects = getEffectMetadataEntries(target);\n        var /** @type {?} */ metadata = { propertyName: propertyName, dispatch: dispatch };\n        setEffectMetadataEntries(target, effects.concat([metadata]));\n    };\n}\n/**\n * @param {?} instance\n * @return {?}\n */\nfunction getSourceForInstance(instance) {\n    return Object.getPrototypeOf(instance);\n}\nvar getSourceMetadata = compose(getEffectMetadataEntries, getSourceForInstance);\nvar onRunEffectsKey = 'ngrxOnRunEffects';\n/**\n * @param {?} sourceInstance\n * @return {?}\n */\nfunction isOnRunEffects(sourceInstance) {\n    var /** @type {?} */ source = getSourceForInstance(sourceInstance);\n    return (onRunEffectsKey in source && typeof source[onRunEffectsKey] === 'function');\n}\n/**\n * @param {?} sourceInstance\n * @return {?}\n */\nfunction mergeEffects(sourceInstance) {\n    var /** @type {?} */ sourceName = getSourceForInstance(sourceInstance).constructor.name;\n    var /** @type {?} */ observables = getSourceMetadata(sourceInstance).map(function (_a) {\n        var propertyName = _a.propertyName, dispatch = _a.dispatch;\n        var /** @type {?} */ observable = typeof sourceInstance[propertyName] === 'function'\n            ? sourceInstance[propertyName]()\n            : sourceInstance[propertyName];\n        if (dispatch === false) {\n            return ignoreElements.call(observable);\n        }\n        var /** @type {?} */ materialized$ = materialize.call(observable);\n        return map.call(materialized$, function (notification) { return ({\n            effect: sourceInstance[propertyName],\n            notification: notification,\n            propertyName: propertyName,\n            sourceName: sourceName,\n            sourceInstance: sourceInstance,\n        }); });\n    });\n    return merge.apply(void 0, observables);\n}\n/**\n * @param {?} sourceInstance\n * @return {?}\n */\nfunction resolveEffectSource(sourceInstance) {\n    var /** @type {?} */ mergedEffects$ = mergeEffects(sourceInstance);\n    if (isOnRunEffects(sourceInstance)) {\n        return sourceInstance.ngrxOnRunEffects(mergedEffects$);\n    }\n    return mergedEffects$;\n}\nvar Actions = (function (_super) {\n    __extends(Actions, _super);\n    /**\n     * @param {?=} source\n     */\n    function Actions(source) {\n        var _this = _super.call(this) || this;\n        if (source) {\n            _this.source = source;\n        }\n        return _this;\n    }\n    /**\n     * @template R\n     * @param {?} operator\n     * @return {?}\n     */\n    Actions.prototype.lift = function (operator) {\n        var /** @type {?} */ observable = new Actions();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    /**\n     * @template V2\n     * @param {...?} allowedTypes\n     * @return {?}\n     */\n    Actions.prototype.ofType = function () {\n        var allowedTypes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            allowedTypes[_i] = arguments[_i];\n        }\n        return filter.call(this, function (action) { return allowedTypes.some(function (type) { return type === action.type; }); });\n    };\n    return Actions;\n}(Observable));\nActions.decorators = [\n    { type: Injectable },\n];\n/**\n * @nocollapse\n */\nActions.ctorParameters = function () { return [\n    { type: Observable, decorators: [{ type: Inject, args: [ScannedActionsSubject,] },] },\n]; };\n/**\n * @param {?} output\n * @param {?} reporter\n * @return {?}\n */\nfunction verifyOutput(output, reporter) {\n    reportErrorThrown(output, reporter);\n    reportInvalidActions(output, reporter);\n}\n/**\n * @param {?} output\n * @param {?} reporter\n * @return {?}\n */\nfunction reportErrorThrown(output, reporter) {\n    if (output.notification.kind === 'E') {\n        var /** @type {?} */ errorReason = \"Effect \" + getEffectName(output) + \" threw an error\";\n        reporter.report(errorReason, {\n            Source: output.sourceInstance,\n            Effect: output.effect,\n            Error: output.notification.error,\n            Notification: output.notification,\n        });\n    }\n}\n/**\n * @param {?} output\n * @param {?} reporter\n * @return {?}\n */\nfunction reportInvalidActions(output, reporter) {\n    if (output.notification.kind === 'N') {\n        var /** @type {?} */ action = output.notification.value;\n        var /** @type {?} */ isInvalidAction = !isAction(action);\n        if (isInvalidAction) {\n            var /** @type {?} */ errorReason = \"Effect \" + getEffectName(output) + \" dispatched an invalid action\";\n            reporter.report(errorReason, {\n                Source: output.sourceInstance,\n                Effect: output.effect,\n                Dispatched: action,\n                Notification: output.notification,\n            });\n        }\n    }\n}\n/**\n * @param {?} action\n * @return {?}\n */\nfunction isAction(action) {\n    return action && action.type && typeof action.type === 'string';\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction getEffectName(_a) {\n    var propertyName = _a.propertyName, sourceInstance = _a.sourceInstance, sourceName = _a.sourceName;\n    var /** @type {?} */ isMethod = typeof sourceInstance[propertyName] === 'function';\n    return \"\\\"\" + sourceName + \".\" + propertyName + (isMethod ? '()' : '') + \"\\\"\";\n}\nvar IMMEDIATE_EFFECTS = new InjectionToken('ngrx/effects: Immediate Effects');\nvar ROOT_EFFECTS = new InjectionToken('ngrx/effects: Root Effects');\nvar FEATURE_EFFECTS = new InjectionToken('ngrx/effects: Feature Effects');\nvar CONSOLE = new InjectionToken('Browser Console');\nvar ErrorReporter = (function () {\n    /**\n     * @param {?} console\n     */\n    function ErrorReporter(console) {\n        this.console = console;\n    }\n    /**\n     * @param {?} reason\n     * @param {?} details\n     * @return {?}\n     */\n    ErrorReporter.prototype.report = function (reason, details) {\n        this.console.group(reason);\n        for (var /** @type {?} */ key in details) {\n            this.console.error(key + \":\", details[key]);\n        }\n        this.console.groupEnd();\n    };\n    return ErrorReporter;\n}());\nErrorReporter.decorators = [\n    { type: Injectable },\n];\n/**\n * @nocollapse\n */\nErrorReporter.ctorParameters = function () { return [\n    { type: undefined, decorators: [{ type: Inject, args: [CONSOLE,] },] },\n]; };\nvar EffectSources = (function (_super) {\n    __extends(EffectSources, _super);\n    /**\n     * @param {?} errorReporter\n     */\n    function EffectSources(errorReporter) {\n        var _this = _super.call(this) || this;\n        _this.errorReporter = errorReporter;\n        return _this;\n    }\n    /**\n     * @param {?} effectSourceInstance\n     * @return {?}\n     */\n    EffectSources.prototype.addEffects = function (effectSourceInstance) {\n        this.next(effectSourceInstance);\n    };\n    /**\n     * @return {?}\n     */\n    EffectSources.prototype.toActions = function () {\n        var _this = this;\n        return mergeMap.call(groupBy.call(this, getSourceForInstance), function (source$) { return dematerialize.call(filter.call(map.call(exhaustMap.call(source$, resolveEffectSource), function (output) {\n            verifyOutput(output, _this.errorReporter);\n            return output.notification;\n        }), function (notification) { return notification.kind === 'N'; })); });\n    };\n    return EffectSources;\n}(Subject));\nEffectSources.decorators = [\n    { type: Injectable },\n];\n/**\n * @nocollapse\n */\nEffectSources.ctorParameters = function () { return [\n    { type: ErrorReporter, },\n]; };\nvar EffectsRunner = (function () {\n    /**\n     * @param {?} effectSources\n     * @param {?} store\n     */\n    function EffectsRunner(effectSources, store) {\n        this.effectSources = effectSources;\n        this.store = store;\n        this.effectsSubscription = null;\n    }\n    /**\n     * @return {?}\n     */\n    EffectsRunner.prototype.start = function () {\n        if (!this.effectsSubscription) {\n            this.effectsSubscription = this.effectSources\n                .toActions()\n                .subscribe(this.store);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    EffectsRunner.prototype.ngOnDestroy = function () {\n        if (this.effectsSubscription) {\n            this.effectsSubscription.unsubscribe();\n            this.effectsSubscription = null;\n        }\n    };\n    return EffectsRunner;\n}());\nEffectsRunner.decorators = [\n    { type: Injectable },\n];\n/**\n * @nocollapse\n */\nEffectsRunner.ctorParameters = function () { return [\n    { type: EffectSources, },\n    { type: Store, },\n]; };\nvar EffectsRootModule = (function () {\n    /**\n     * @param {?} sources\n     * @param {?} runner\n     * @param {?} rootEffects\n     * @param {?} storeModule\n     */\n    function EffectsRootModule(sources, runner, rootEffects, storeModule) {\n        this.sources = sources;\n        runner.start();\n        rootEffects.forEach(function (effectSourceInstance) { return sources.addEffects(effectSourceInstance); });\n    }\n    /**\n     * @param {?} effectSourceInstance\n     * @return {?}\n     */\n    EffectsRootModule.prototype.addEffects = function (effectSourceInstance) {\n        this.sources.addEffects(effectSourceInstance);\n    };\n    return EffectsRootModule;\n}());\nEffectsRootModule.decorators = [\n    { type: NgModule, args: [{},] },\n];\n/**\n * @nocollapse\n */\nEffectsRootModule.ctorParameters = function () { return [\n    { type: EffectSources, },\n    { type: EffectsRunner, },\n    { type: Array, decorators: [{ type: Inject, args: [ROOT_EFFECTS,] },] },\n    { type: StoreModule, decorators: [{ type: Optional },] },\n]; };\nvar EffectsFeatureModule = (function () {\n    /**\n     * @param {?} root\n     * @param {?} effectSourceGroups\n     * @param {?} storeModule\n     */\n    function EffectsFeatureModule(root, effectSourceGroups, storeModule) {\n        this.root = root;\n        effectSourceGroups.forEach(function (group) { return group.forEach(function (effectSourceInstance) { return root.addEffects(effectSourceInstance); }); });\n    }\n    return EffectsFeatureModule;\n}());\nEffectsFeatureModule.decorators = [\n    { type: NgModule, args: [{},] },\n];\n/**\n * @nocollapse\n */\nEffectsFeatureModule.ctorParameters = function () { return [\n    { type: EffectsRootModule, },\n    { type: Array, decorators: [{ type: Inject, args: [FEATURE_EFFECTS,] },] },\n    { type: StoreModule, decorators: [{ type: Optional },] },\n]; };\nvar EffectsModule = (function () {\n    function EffectsModule() {\n    }\n    /**\n     * @param {?} featureEffects\n     * @return {?}\n     */\n    EffectsModule.forFeature = function (featureEffects) {\n        return {\n            ngModule: EffectsFeatureModule,\n            providers: [\n                featureEffects,\n                {\n                    provide: FEATURE_EFFECTS,\n                    multi: true,\n                    deps: featureEffects,\n                    useFactory: createSourceInstances,\n                },\n            ],\n        };\n    };\n    /**\n     * @param {?} rootEffects\n     * @return {?}\n     */\n    EffectsModule.forRoot = function (rootEffects) {\n        return {\n            ngModule: EffectsRootModule,\n            providers: [\n                EffectsRunner,\n                EffectSources,\n                ErrorReporter,\n                Actions,\n                rootEffects,\n                {\n                    provide: ROOT_EFFECTS,\n                    deps: rootEffects,\n                    useFactory: createSourceInstances,\n                },\n                {\n                    provide: CONSOLE,\n                    useFactory: getConsole,\n                },\n            ],\n        };\n    };\n    return EffectsModule;\n}());\nEffectsModule.decorators = [\n    { type: NgModule, args: [{},] },\n];\n/**\n * @nocollapse\n */\nEffectsModule.ctorParameters = function () { return []; };\n/**\n * @param {...?} instances\n * @return {?}\n */\nfunction createSourceInstances() {\n    var instances = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        instances[_i] = arguments[_i];\n    }\n    return instances;\n}\n/**\n * @return {?}\n */\nfunction getConsole() {\n    return console;\n}\n/**\n * @deprecated Since version 4.1. Will be deleted in version 5.0.\n * @param {?} action\n * @return {?}\n */\nfunction toPayload(action) {\n    return ((action)).payload;\n}\n/**\n * Generated bundle index. Do not edit.\n */\nexport { Effect, mergeEffects, Actions, EffectsModule, EffectSources, toPayload, EffectsFeatureModule as ɵc, createSourceInstances as ɵa, getConsole as ɵb, EffectsRootModule as ɵg, EffectsRunner as ɵi, ErrorReporter as ɵh, CONSOLE as ɵf, FEATURE_EFFECTS as ɵe, ROOT_EFFECTS as ɵd };\n//# sourceMappingURL=effects.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/@ngrx/effects/@ngrx/effects.es5.js\n// module id = ../../../../@ngrx/effects/@ngrx/effects.es5.js\n// module chunks = common","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Inject, Injectable, InjectionToken, NgModule } from '@angular/core';\nimport { ActionsSubject, INIT, INITIAL_STATE, ReducerManagerDispatcher, ReducerObservable, ScannedActionsSubject, StateObservable, UPDATE } from '@ngrx/store';\nimport { ReplaySubject } from 'rxjs/ReplaySubject';\nimport { map } from 'rxjs/operator/map';\nimport { merge } from 'rxjs/operator/merge';\nimport { observeOn } from 'rxjs/operator/observeOn';\nimport { scan } from 'rxjs/operator/scan';\nimport { skip } from 'rxjs/operator/skip';\nimport { withLatestFrom } from 'rxjs/operator/withLatestFrom';\nimport { queue } from 'rxjs/scheduler/queue';\nimport { Observable } from 'rxjs/Observable';\nimport { empty } from 'rxjs/observable/empty';\nimport { filter } from 'rxjs/operator/filter';\nimport { share } from 'rxjs/operator/share';\nimport { switchMap } from 'rxjs/operator/switchMap';\nimport { takeUntil } from 'rxjs/operator/takeUntil';\nvar PERFORM_ACTION = 'PERFORM_ACTION';\nvar RESET = 'RESET';\nvar ROLLBACK = 'ROLLBACK';\nvar COMMIT = 'COMMIT';\nvar SWEEP = 'SWEEP';\nvar TOGGLE_ACTION = 'TOGGLE_ACTION';\nvar SET_ACTIONS_ACTIVE = 'SET_ACTIONS_ACTIVE';\nvar JUMP_TO_STATE = 'JUMP_TO_STATE';\nvar IMPORT_STATE = 'IMPORT_STATE';\nvar PerformAction = (function () {\n    /**\n     * @param {?} action\n     * @param {?=} timestamp\n     */\n    function PerformAction(action, timestamp) {\n        this.action = action;\n        this.timestamp = timestamp;\n        this.type = PERFORM_ACTION;\n        if (typeof action.type === 'undefined') {\n            throw new Error('Actions may not have an undefined \"type\" property. ' +\n                'Have you misspelled a constant?');\n        }\n    }\n    return PerformAction;\n}());\nvar Reset = (function () {\n    /**\n     * @param {?=} timestamp\n     */\n    function Reset(timestamp) {\n        this.timestamp = timestamp;\n        this.type = RESET;\n    }\n    return Reset;\n}());\nvar Rollback = (function () {\n    /**\n     * @param {?=} timestamp\n     */\n    function Rollback(timestamp) {\n        this.timestamp = timestamp;\n        this.type = ROLLBACK;\n    }\n    return Rollback;\n}());\nvar Commit = (function () {\n    /**\n     * @param {?=} timestamp\n     */\n    function Commit(timestamp) {\n        this.timestamp = timestamp;\n        this.type = COMMIT;\n    }\n    return Commit;\n}());\nvar Sweep = (function () {\n    function Sweep() {\n        this.type = SWEEP;\n    }\n    return Sweep;\n}());\nvar ToggleAction = (function () {\n    /**\n     * @param {?} id\n     */\n    function ToggleAction(id) {\n        this.id = id;\n        this.type = TOGGLE_ACTION;\n    }\n    return ToggleAction;\n}());\nvar JumpToState = (function () {\n    /**\n     * @param {?} index\n     */\n    function JumpToState(index) {\n        this.index = index;\n        this.type = JUMP_TO_STATE;\n    }\n    return JumpToState;\n}());\nvar ImportState = (function () {\n    /**\n     * @param {?} nextLiftedState\n     */\n    function ImportState(nextLiftedState) {\n        this.nextLiftedState = nextLiftedState;\n        this.type = IMPORT_STATE;\n    }\n    return ImportState;\n}());\n/**\n * @param {?} first\n * @param {?} second\n * @return {?}\n */\nfunction difference(first, second) {\n    return first.filter(function (item) { return second.indexOf(item) < 0; });\n}\n/**\n * Provides an app's view into the state of the lifted store.\n * @param {?} liftedState\n * @return {?}\n */\nfunction unliftState(liftedState) {\n    var computedStates = liftedState.computedStates, currentStateIndex = liftedState.currentStateIndex;\n    var state = computedStates[currentStateIndex].state;\n    return state;\n}\n/**\n * @param {?} liftedState\n * @return {?}\n */\n/**\n * Lifts an app's action into an action on the lifted store.\n * @param {?} action\n * @return {?}\n */\nfunction liftAction(action) {\n    return new PerformAction(action);\n}\n/**\n * @param {?} input$\n * @param {?} operators\n * @return {?}\n */\nfunction applyOperators(input$, operators) {\n    return operators.reduce(function (source$, _a) {\n        var operator = _a[0], args = _a.slice(1);\n        return operator.apply(source$, args);\n    }, input$);\n}\nvar ExtensionActionTypes = {\n    START: 'START',\n    DISPATCH: 'DISPATCH',\n    STOP: 'STOP',\n    ACTION: 'ACTION',\n};\nvar REDUX_DEVTOOLS_EXTENSION = new InjectionToken('Redux Devtools Extension');\nvar DevtoolsExtension = (function () {\n    /**\n     * @param {?} devtoolsExtension\n     */\n    function DevtoolsExtension(devtoolsExtension) {\n        this.instanceId = \"ngrx-store-\" + Date.now();\n        this.devtoolsExtension = devtoolsExtension;\n        this.createActionStreams();\n    }\n    /**\n     * @param {?} action\n     * @param {?} state\n     * @return {?}\n     */\n    DevtoolsExtension.prototype.notify = function (action, state) {\n        if (!this.devtoolsExtension) {\n            return;\n        }\n        this.devtoolsExtension.send(null, state, { serialize: false }, this.instanceId);\n    };\n    /**\n     * @return {?}\n     */\n    DevtoolsExtension.prototype.createChangesObservable = function () {\n        var _this = this;\n        if (!this.devtoolsExtension) {\n            return empty();\n        }\n        return new Observable(function (subscriber) {\n            var /** @type {?} */ connection = _this.devtoolsExtension.connect({\n                instanceId: _this.instanceId,\n            });\n            connection.subscribe(function (change) { return subscriber.next(change); });\n            return connection.unsubscribe;\n        });\n    };\n    /**\n     * @return {?}\n     */\n    DevtoolsExtension.prototype.createActionStreams = function () {\n        var _this = this;\n        // Listens to all changes based on our instanceId\n        var /** @type {?} */ changes$ = share.call(this.createChangesObservable());\n        // Listen for the start action\n        var /** @type {?} */ start$ = filter.call(changes$, function (change) { return change.type === ExtensionActionTypes.START; });\n        // Listen for the stop action\n        var /** @type {?} */ stop$ = filter.call(changes$, function (change) { return change.type === ExtensionActionTypes.STOP; });\n        // Listen for lifted actions\n        var /** @type {?} */ liftedActions$ = applyOperators(changes$, [\n            [filter, function (change) { return change.type === ExtensionActionTypes.DISPATCH; }],\n            [map, function (change) { return _this.unwrapAction(change.payload); }],\n        ]);\n        // Listen for unlifted actions\n        var /** @type {?} */ actions$ = applyOperators(changes$, [\n            [filter, function (change) { return change.type === ExtensionActionTypes.ACTION; }],\n            [map, function (change) { return _this.unwrapAction(change.payload); }],\n        ]);\n        var /** @type {?} */ actionsUntilStop$ = takeUntil.call(actions$, stop$);\n        var /** @type {?} */ liftedUntilStop$ = takeUntil.call(liftedActions$, stop$);\n        // Only take the action sources between the start/stop events\n        this.actions$ = switchMap.call(start$, function () { return actionsUntilStop$; });\n        this.liftedActions$ = switchMap.call(start$, function () { return liftedUntilStop$; });\n    };\n    /**\n     * @param {?} action\n     * @return {?}\n     */\n    DevtoolsExtension.prototype.unwrapAction = function (action) {\n        return typeof action === 'string' ? eval(\"(\" + action + \")\") : action;\n    };\n    return DevtoolsExtension;\n}());\nDevtoolsExtension.decorators = [\n    { type: Injectable },\n];\n/**\n * @nocollapse\n */\nDevtoolsExtension.ctorParameters = function () { return [\n    { type: undefined, decorators: [{ type: Inject, args: [REDUX_DEVTOOLS_EXTENSION,] },] },\n]; };\nvar INIT_ACTION = { type: INIT };\n/**\n * Computes the next entry in the log by applying an action.\n * @param {?} reducer\n * @param {?} action\n * @param {?} state\n * @param {?} error\n * @return {?}\n */\nfunction computeNextEntry(reducer, action, state, error) {\n    if (error) {\n        return {\n            state: state,\n            error: 'Interrupted by an error up the chain',\n        };\n    }\n    var /** @type {?} */ nextState = state;\n    var /** @type {?} */ nextError;\n    try {\n        nextState = reducer(state, action);\n    }\n    catch (err) {\n        nextError = err.toString();\n        console.error(err.stack || err);\n    }\n    return {\n        state: nextState,\n        error: nextError,\n    };\n}\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n * @param {?} computedStates\n * @param {?} minInvalidatedStateIndex\n * @param {?} reducer\n * @param {?} committedState\n * @param {?} actionsById\n * @param {?} stagedActionIds\n * @param {?} skippedActionIds\n * @return {?}\n */\nfunction recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds) {\n    // Optimization: exit early and return the same reference\n    // if we know nothing could have changed.\n    if (minInvalidatedStateIndex >= computedStates.length &&\n        computedStates.length === stagedActionIds.length) {\n        return computedStates;\n    }\n    var /** @type {?} */ nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n    for (var /** @type {?} */ i = minInvalidatedStateIndex; i < stagedActionIds.length; i++) {\n        var /** @type {?} */ actionId = stagedActionIds[i];\n        var /** @type {?} */ action = actionsById[actionId].action;\n        var /** @type {?} */ previousEntry = nextComputedStates[i - 1];\n        var /** @type {?} */ previousState = previousEntry ? previousEntry.state : committedState;\n        var /** @type {?} */ previousError = previousEntry ? previousEntry.error : undefined;\n        var /** @type {?} */ shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n        var /** @type {?} */ entry = shouldSkip\n            ? previousEntry\n            : computeNextEntry(reducer, action, previousState, previousError);\n        nextComputedStates.push(entry);\n    }\n    return nextComputedStates;\n}\n/**\n * @param {?=} initialCommittedState\n * @param {?=} monitorReducer\n * @return {?}\n */\nfunction liftInitialState(initialCommittedState, monitorReducer) {\n    return {\n        monitorState: monitorReducer(undefined, {}),\n        nextActionId: 1,\n        actionsById: { 0: liftAction(INIT_ACTION) },\n        stagedActionIds: [0],\n        skippedActionIds: [],\n        committedState: initialCommittedState,\n        currentStateIndex: 0,\n        computedStates: [],\n    };\n}\n/**\n * Creates a history state reducer from an app's reducer.\n * @param {?} initialCommittedState\n * @param {?} initialLiftedState\n * @param {?=} monitorReducer\n * @param {?=} options\n * @return {?}\n */\nfunction liftReducerWith(initialCommittedState, initialLiftedState, monitorReducer, options) {\n    if (options === void 0) { options = {}; }\n    /**\n    * Manages how the history actions modify the history state.\n    */\n    return function (reducer) { return function (liftedState, liftedAction) {\n        var _a = liftedState || initialLiftedState, monitorState = _a.monitorState, actionsById = _a.actionsById, nextActionId = _a.nextActionId, stagedActionIds = _a.stagedActionIds, skippedActionIds = _a.skippedActionIds, committedState = _a.committedState, currentStateIndex = _a.currentStateIndex, computedStates = _a.computedStates;\n        if (!liftedState) {\n            // Prevent mutating initialLiftedState\n            actionsById = Object.create(actionsById);\n        }\n        /**\n         * @param {?} n\n         * @return {?}\n         */\n        function commitExcessActions(n) {\n            // Auto-commits n-number of excess actions.\n            var /** @type {?} */ excess = n;\n            var /** @type {?} */ idsToDelete = stagedActionIds.slice(1, excess + 1);\n            for (var /** @type {?} */ i = 0; i < idsToDelete.length; i++) {\n                if (computedStates[i + 1].error) {\n                    // Stop if error is found. Commit actions up to error.\n                    excess = i;\n                    idsToDelete = stagedActionIds.slice(1, excess + 1);\n                    break;\n                }\n                else {\n                    delete actionsById[idsToDelete[i]];\n                }\n            }\n            skippedActionIds = skippedActionIds.filter(function (id) { return idsToDelete.indexOf(id) === -1; });\n            stagedActionIds = [0].concat(stagedActionIds.slice(excess + 1));\n            committedState = computedStates[excess].state;\n            computedStates = computedStates.slice(excess);\n            currentStateIndex =\n                currentStateIndex > excess ? currentStateIndex - excess : 0;\n        }\n        // By default, agressively recompute every state whatever happens.\n        // This has O(n) performance, so we'll override this to a sensible\n        // value whenever we feel like we don't have to recompute the states.\n        var /** @type {?} */ minInvalidatedStateIndex = 0;\n        switch (liftedAction.type) {\n            case RESET: {\n                // Get back to the state the store was created with.\n                actionsById = { 0: liftAction(INIT_ACTION) };\n                nextActionId = 1;\n                stagedActionIds = [0];\n                skippedActionIds = [];\n                committedState = initialCommittedState;\n                currentStateIndex = 0;\n                computedStates = [];\n                break;\n            }\n            case COMMIT: {\n                // Consider the last committed state the new starting point.\n                // Squash any staged actions into a single committed state.\n                actionsById = { 0: liftAction(INIT_ACTION) };\n                nextActionId = 1;\n                stagedActionIds = [0];\n                skippedActionIds = [];\n                committedState = computedStates[currentStateIndex].state;\n                currentStateIndex = 0;\n                computedStates = [];\n                break;\n            }\n            case ROLLBACK: {\n                // Forget about any staged actions.\n                // Start again from the last committed state.\n                actionsById = { 0: liftAction(INIT_ACTION) };\n                nextActionId = 1;\n                stagedActionIds = [0];\n                skippedActionIds = [];\n                currentStateIndex = 0;\n                computedStates = [];\n                break;\n            }\n            case TOGGLE_ACTION: {\n                // Toggle whether an action with given ID is skipped.\n                // Being skipped means it is a no-op during the computation.\n                var actionId_1 = liftedAction.id;\n                var /** @type {?} */ index = skippedActionIds.indexOf(actionId_1);\n                if (index === -1) {\n                    skippedActionIds = [actionId_1].concat(skippedActionIds);\n                }\n                else {\n                    skippedActionIds = skippedActionIds.filter(function (id) { return id !== actionId_1; });\n                }\n                // Optimization: we know history before this action hasn't changed\n                minInvalidatedStateIndex = stagedActionIds.indexOf(actionId_1);\n                break;\n            }\n            case SET_ACTIONS_ACTIVE: {\n                // Toggle whether an action with given ID is skipped.\n                // Being skipped means it is a no-op during the computation.\n                var start = liftedAction.start, end = liftedAction.end, active = liftedAction.active;\n                var /** @type {?} */ actionIds = [];\n                for (var /** @type {?} */ i = start; i < end; i++)\n                    actionIds.push(i);\n                if (active) {\n                    skippedActionIds = difference(skippedActionIds, actionIds);\n                }\n                else {\n                    skippedActionIds = skippedActionIds.concat(actionIds);\n                }\n                // Optimization: we know history before this action hasn't changed\n                minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n                break;\n            }\n            case JUMP_TO_STATE: {\n                // Without recomputing anything, move the pointer that tell us\n                // which state is considered the current one. Useful for sliders.\n                currentStateIndex = liftedAction.index;\n                // Optimization: we know the history has not changed.\n                minInvalidatedStateIndex = Infinity;\n                break;\n            }\n            case SWEEP: {\n                // Forget any actions that are currently being skipped.\n                stagedActionIds = difference(stagedActionIds, skippedActionIds);\n                skippedActionIds = [];\n                currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n                break;\n            }\n            case PERFORM_ACTION: {\n                // Auto-commit as new actions come in.\n                if (options.maxAge && stagedActionIds.length === options.maxAge) {\n                    commitExcessActions(1);\n                }\n                if (currentStateIndex === stagedActionIds.length - 1) {\n                    currentStateIndex++;\n                }\n                var /** @type {?} */ actionId = nextActionId++;\n                // Mutation! This is the hottest path, and we optimize on purpose.\n                // It is safe because we set a new key in a cache dictionary.\n                actionsById[actionId] = liftedAction;\n                stagedActionIds = stagedActionIds.concat([actionId]);\n                // Optimization: we know that only the new action needs computing.\n                minInvalidatedStateIndex = stagedActionIds.length - 1;\n                break;\n            }\n            case IMPORT_STATE: {\n                // Completely replace everything.\n                (_b = liftedAction.nextLiftedState, monitorState = _b.monitorState, actionsById = _b.actionsById, nextActionId = _b.nextActionId, stagedActionIds = _b.stagedActionIds, skippedActionIds = _b.skippedActionIds, committedState = _b.committedState, currentStateIndex = _b.currentStateIndex, computedStates = _b.computedStates);\n                break;\n            }\n            case UPDATE:\n            case INIT: {\n                // Always recompute states on hot reload and init.\n                minInvalidatedStateIndex = 0;\n                if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                    // States must be recomputed before committing excess.\n                    computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds);\n                    commitExcessActions(stagedActionIds.length - options.maxAge);\n                    // Avoid double computation.\n                    minInvalidatedStateIndex = Infinity;\n                }\n                break;\n            }\n            default: {\n                // If the action is not recognized, it's a monitor action.\n                // Optimization: a monitor action can't change history.\n                minInvalidatedStateIndex = Infinity;\n                break;\n            }\n        }\n        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds);\n        monitorState = monitorReducer(monitorState, liftedAction);\n        return {\n            monitorState: monitorState,\n            actionsById: actionsById,\n            nextActionId: nextActionId,\n            stagedActionIds: stagedActionIds,\n            skippedActionIds: skippedActionIds,\n            committedState: committedState,\n            currentStateIndex: currentStateIndex,\n            computedStates: computedStates,\n        };\n        var _b;\n    }; };\n}\nvar StoreDevtoolsConfig = (function () {\n    function StoreDevtoolsConfig() {\n    }\n    return StoreDevtoolsConfig;\n}());\nvar STORE_DEVTOOLS_CONFIG = new InjectionToken('@ngrx/devtools Options');\nvar INITIAL_OPTIONS = new InjectionToken('@ngrx/devtools Initial Config');\nvar DevtoolsDispatcher = (function (_super) {\n    __extends(DevtoolsDispatcher, _super);\n    function DevtoolsDispatcher() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return DevtoolsDispatcher;\n}(ActionsSubject));\nDevtoolsDispatcher.decorators = [\n    { type: Injectable },\n];\n/**\n * @nocollapse\n */\nDevtoolsDispatcher.ctorParameters = function () { return []; };\nvar StoreDevtools = (function () {\n    /**\n     * @param {?} dispatcher\n     * @param {?} actions$\n     * @param {?} reducers$\n     * @param {?} extension\n     * @param {?} scannedActions\n     * @param {?} initialState\n     * @param {?} config\n     */\n    function StoreDevtools(dispatcher, actions$, reducers$, extension, scannedActions, initialState, config) {\n        var liftedInitialState = liftInitialState(initialState, config.monitor);\n        var liftReducer = liftReducerWith(initialState, liftedInitialState, config.monitor, config.maxAge ? { maxAge: config.maxAge } : {});\n        var liftedAction$ = applyOperators(actions$.asObservable(), [\n            [skip, 1],\n            [merge, extension.actions$],\n            [map, liftAction],\n            [merge, dispatcher, extension.liftedActions$],\n            [observeOn, queue],\n        ]);\n        var liftedReducer$ = map.call(reducers$, liftReducer);\n        var liftedStateSubject = new ReplaySubject(1);\n        var liftedStateSubscription = applyOperators(liftedAction$, [\n            [withLatestFrom, liftedReducer$],\n            [\n                scan,\n                function (_a, _b) {\n                    var liftedState = _a.state;\n                    var action = _b[0], reducer = _b[1];\n                    var state = reducer(liftedState, action);\n                    extension.notify(action, state);\n                    return { state: state, action: action };\n                },\n                { state: liftedInitialState, action: null },\n            ],\n        ]).subscribe(function (_a) {\n            var state = _a.state, action = _a.action;\n            liftedStateSubject.next(state);\n            if (action.type === PERFORM_ACTION) {\n                var unlifedAction = action.action;\n                scannedActions.next(unlifedAction);\n            }\n        });\n        var liftedState$ = liftedStateSubject.asObservable();\n        var state$ = map.call(liftedState$, unliftState);\n        this.stateSubscription = liftedStateSubscription;\n        this.dispatcher = dispatcher;\n        this.liftedState = liftedState$;\n        this.state = state$;\n    }\n    /**\n     * @param {?} action\n     * @return {?}\n     */\n    StoreDevtools.prototype.dispatch = function (action) {\n        this.dispatcher.next(action);\n    };\n    /**\n     * @param {?} action\n     * @return {?}\n     */\n    StoreDevtools.prototype.next = function (action) {\n        this.dispatcher.next(action);\n    };\n    /**\n     * @param {?} error\n     * @return {?}\n     */\n    StoreDevtools.prototype.error = function (error) { };\n    /**\n     * @return {?}\n     */\n    StoreDevtools.prototype.complete = function () { };\n    /**\n     * @param {?} action\n     * @return {?}\n     */\n    StoreDevtools.prototype.performAction = function (action) {\n        this.dispatch(new PerformAction(action));\n    };\n    /**\n     * @return {?}\n     */\n    StoreDevtools.prototype.reset = function () {\n        this.dispatch(new Reset());\n    };\n    /**\n     * @return {?}\n     */\n    StoreDevtools.prototype.rollback = function () {\n        this.dispatch(new Rollback());\n    };\n    /**\n     * @return {?}\n     */\n    StoreDevtools.prototype.commit = function () {\n        this.dispatch(new Commit());\n    };\n    /**\n     * @return {?}\n     */\n    StoreDevtools.prototype.sweep = function () {\n        this.dispatch(new Sweep());\n    };\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    StoreDevtools.prototype.toggleAction = function (id) {\n        this.dispatch(new ToggleAction(id));\n    };\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n    StoreDevtools.prototype.jumpToState = function (index) {\n        this.dispatch(new JumpToState(index));\n    };\n    /**\n     * @param {?} nextLiftedState\n     * @return {?}\n     */\n    StoreDevtools.prototype.importState = function (nextLiftedState) {\n        this.dispatch(new ImportState(nextLiftedState));\n    };\n    return StoreDevtools;\n}());\nStoreDevtools.decorators = [\n    { type: Injectable },\n];\n/**\n * @nocollapse\n */\nStoreDevtools.ctorParameters = function () { return [\n    { type: DevtoolsDispatcher, },\n    { type: ActionsSubject, },\n    { type: ReducerObservable, },\n    { type: DevtoolsExtension, },\n    { type: ScannedActionsSubject, },\n    { type: undefined, decorators: [{ type: Inject, args: [INITIAL_STATE,] },] },\n    { type: StoreDevtoolsConfig, decorators: [{ type: Inject, args: [STORE_DEVTOOLS_CONFIG,] },] },\n]; };\nvar IS_EXTENSION_OR_MONITOR_PRESENT = new InjectionToken('Is Devtools Extension or Monitor Present');\n/**\n * @param {?} extension\n * @param {?} config\n * @return {?}\n */\nfunction createIsExtensionOrMonitorPresent(extension, config) {\n    return Boolean(extension) || config.monitor !== noMonitor;\n}\n/**\n * @return {?}\n */\nfunction createReduxDevtoolsExtension() {\n    var /** @type {?} */ extensionKey = '__REDUX_DEVTOOLS_EXTENSION__';\n    if (typeof window === 'object' &&\n        typeof ((window))[extensionKey] !== 'undefined') {\n        return ((window))[extensionKey];\n    }\n    else {\n        return null;\n    }\n}\n/**\n * @param {?} devtools\n * @return {?}\n */\nfunction createStateObservable(devtools) {\n    return devtools.state;\n}\n/**\n * @return {?}\n */\nfunction noMonitor() {\n    return null;\n}\n/**\n * @param {?} _options\n * @return {?}\n */\nfunction createConfig(_options) {\n    var /** @type {?} */ DEFAULT_OPTIONS = {\n        maxAge: false,\n        monitor: noMonitor,\n    };\n    var /** @type {?} */ options = typeof _options === 'function' ? _options() : _options;\n    var /** @type {?} */ config = Object.assign({}, DEFAULT_OPTIONS, options);\n    if (config.maxAge && config.maxAge < 2) {\n        throw new Error(\"Devtools 'maxAge' cannot be less than 2, got \" + config.maxAge);\n    }\n    return config;\n}\nvar StoreDevtoolsModule = (function () {\n    function StoreDevtoolsModule() {\n    }\n    /**\n     * @param {?=} options\n     * @return {?}\n     */\n    StoreDevtoolsModule.instrument = function (options) {\n        if (options === void 0) { options = {}; }\n        return {\n            ngModule: StoreDevtoolsModule,\n            providers: [\n                DevtoolsExtension,\n                DevtoolsDispatcher,\n                StoreDevtools,\n                {\n                    provide: INITIAL_OPTIONS,\n                    useValue: options,\n                },\n                {\n                    provide: IS_EXTENSION_OR_MONITOR_PRESENT,\n                    deps: [REDUX_DEVTOOLS_EXTENSION, STORE_DEVTOOLS_CONFIG],\n                    useFactory: createIsExtensionOrMonitorPresent,\n                },\n                {\n                    provide: REDUX_DEVTOOLS_EXTENSION,\n                    useFactory: createReduxDevtoolsExtension,\n                },\n                {\n                    provide: STORE_DEVTOOLS_CONFIG,\n                    deps: [INITIAL_OPTIONS],\n                    useFactory: createConfig,\n                },\n                {\n                    provide: StateObservable,\n                    deps: [StoreDevtools],\n                    useFactory: createStateObservable,\n                },\n                {\n                    provide: ReducerManagerDispatcher,\n                    useExisting: DevtoolsDispatcher,\n                },\n            ],\n        };\n    };\n    return StoreDevtoolsModule;\n}());\nStoreDevtoolsModule.decorators = [\n    { type: NgModule, args: [{},] },\n];\n/**\n * @nocollapse\n */\nStoreDevtoolsModule.ctorParameters = function () { return []; };\n/**\n * Generated bundle index. Do not edit.\n */\nexport { StoreDevtoolsModule, StoreDevtools, StoreDevtoolsConfig, INITIAL_OPTIONS as ɵi, STORE_DEVTOOLS_CONFIG as ɵh, DevtoolsDispatcher as ɵg, DevtoolsExtension as ɵk, REDUX_DEVTOOLS_EXTENSION as ɵj, IS_EXTENSION_OR_MONITOR_PRESENT as ɵa, createConfig as ɵf, createIsExtensionOrMonitorPresent as ɵb, createReduxDevtoolsExtension as ɵc, createStateObservable as ɵd, noMonitor as ɵe };\n//# sourceMappingURL=store-devtools.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/@ngrx/store-devtools/@ngrx/store-devtools.es5.js\n// module id = ../../../../@ngrx/store-devtools/@ngrx/store-devtools.es5.js\n// module chunks = common","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Inject, Injectable, InjectionToken, Injector, NgModule } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject';\nimport { Observable } from 'rxjs/Observable';\nimport { Subject } from 'rxjs/Subject';\nimport { queue } from 'rxjs/scheduler/queue';\nimport { observeOn } from 'rxjs/operator/observeOn';\nimport { withLatestFrom } from 'rxjs/operator/withLatestFrom';\nimport { scan } from 'rxjs/operator/scan';\nimport { map } from 'rxjs/operator/map';\nimport { pluck } from 'rxjs/operator/pluck';\nimport { distinctUntilChanged } from 'rxjs/operator/distinctUntilChanged';\n/**\n * @param {?} reducers\n * @param {?=} initialState\n * @return {?}\n */\nfunction combineReducers(reducers, initialState) {\n    if (initialState === void 0) { initialState = {}; }\n    var /** @type {?} */ reducerKeys = Object.keys(reducers);\n    var /** @type {?} */ finalReducers = {};\n    for (var /** @type {?} */ i = 0; i < reducerKeys.length; i++) {\n        var /** @type {?} */ key = reducerKeys[i];\n        if (typeof reducers[key] === 'function') {\n            finalReducers[key] = reducers[key];\n        }\n    }\n    var /** @type {?} */ finalReducerKeys = Object.keys(finalReducers);\n    return function combination(state, action) {\n        if (state === void 0) { state = initialState; }\n        var /** @type {?} */ hasChanged = false;\n        var /** @type {?} */ nextState = {};\n        for (var /** @type {?} */ i = 0; i < finalReducerKeys.length; i++) {\n            var /** @type {?} */ key = finalReducerKeys[i];\n            var /** @type {?} */ reducer = finalReducers[key];\n            var /** @type {?} */ previousStateForKey = state[key];\n            var /** @type {?} */ nextStateForKey = reducer(previousStateForKey, action);\n            nextState[key] = nextStateForKey;\n            hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n        }\n        return hasChanged ? nextState : state;\n    };\n}\n/**\n * @template T\n * @param {?} object\n * @param {?} keyToRemove\n * @return {?}\n */\nfunction omit(object, keyToRemove) {\n    return Object.keys(object)\n        .filter(function (key) { return key !== keyToRemove; })\n        .reduce(function (result, key) {\n        return Object.assign(result, (_a = {}, _a[key] = object[key], _a));\n        var _a;\n    }, {});\n}\n/**\n * @param {...?} functions\n * @return {?}\n */\nfunction compose() {\n    var functions = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        functions[_i] = arguments[_i];\n    }\n    return function (arg) {\n        if (functions.length === 0) {\n            return arg;\n        }\n        var /** @type {?} */ last = functions[functions.length - 1];\n        var /** @type {?} */ rest = functions.slice(0, -1);\n        return rest.reduceRight(function (composed, fn) { return fn(composed); }, last(arg));\n    };\n}\n/**\n * @template T, V\n * @param {?} reducerFactory\n * @param {?=} metaReducers\n * @return {?}\n */\nfunction createReducerFactory(reducerFactory, metaReducers) {\n    if (Array.isArray(metaReducers) && metaReducers.length > 0) {\n        return compose.apply(null, metaReducers.concat([reducerFactory]));\n    }\n    return reducerFactory;\n}\nvar _INITIAL_STATE = new InjectionToken('@ngrx/store Internal Initial State');\nvar INITIAL_STATE = new InjectionToken('@ngrx/store Initial State');\nvar REDUCER_FACTORY = new InjectionToken('@ngrx/store Reducer Factory');\nvar _REDUCER_FACTORY = new InjectionToken('@ngrx/store Reducer Factory Provider');\nvar INITIAL_REDUCERS = new InjectionToken('@ngrx/store Initial Reducers');\nvar _INITIAL_REDUCERS = new InjectionToken('@ngrx/store Internal Initial Reducers');\nvar META_REDUCERS = new InjectionToken('@ngrx/store Meta Reducers');\nvar STORE_FEATURES = new InjectionToken('@ngrx/store Store Features');\nvar _STORE_REDUCERS = new InjectionToken('@ngrx/store Internal Store Reducers');\nvar _FEATURE_REDUCERS = new InjectionToken('@ngrx/store Internal Feature Reducers');\nvar _FEATURE_REDUCERS_TOKEN = new InjectionToken('@ngrx/store Internal Feature Reducers Token');\nvar FEATURE_REDUCERS = new InjectionToken('@ngrx/store Feature Reducers');\nvar INIT = ('@ngrx/store/init');\nvar ActionsSubject = (function (_super) {\n    __extends(ActionsSubject, _super);\n    function ActionsSubject() {\n        return _super.call(this, { type: INIT }) || this;\n    }\n    /**\n     * @param {?} action\n     * @return {?}\n     */\n    ActionsSubject.prototype.next = function (action) {\n        if (typeof action === 'undefined') {\n            throw new TypeError(\"Actions must be objects\");\n        }\n        else if (typeof action.type === 'undefined') {\n            throw new TypeError(\"Actions must have a type property\");\n        }\n        _super.prototype.next.call(this, action);\n    };\n    /**\n     * @return {?}\n     */\n    ActionsSubject.prototype.complete = function () {\n        /* noop */\n    };\n    /**\n     * @return {?}\n     */\n    ActionsSubject.prototype.ngOnDestroy = function () {\n        _super.prototype.complete.call(this);\n    };\n    return ActionsSubject;\n}(BehaviorSubject));\nActionsSubject.decorators = [\n    { type: Injectable },\n];\n/**\n * @nocollapse\n */\nActionsSubject.ctorParameters = function () { return []; };\nvar ACTIONS_SUBJECT_PROVIDERS = [ActionsSubject];\n/**\n * @abstract\n */\nvar ReducerObservable = (function (_super) {\n    __extends(ReducerObservable, _super);\n    function ReducerObservable() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return ReducerObservable;\n}(Observable));\n/**\n * @abstract\n */\nvar ReducerManagerDispatcher = (function (_super) {\n    __extends(ReducerManagerDispatcher, _super);\n    function ReducerManagerDispatcher() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return ReducerManagerDispatcher;\n}(ActionsSubject));\nvar UPDATE = ('@ngrx/store/update-reducers');\nvar ReducerManager = (function (_super) {\n    __extends(ReducerManager, _super);\n    /**\n     * @param {?} dispatcher\n     * @param {?} initialState\n     * @param {?} reducers\n     * @param {?} reducerFactory\n     */\n    function ReducerManager(dispatcher, initialState, reducers, reducerFactory) {\n        var _this = _super.call(this, reducerFactory(reducers, initialState)) || this;\n        _this.dispatcher = dispatcher;\n        _this.initialState = initialState;\n        _this.reducers = reducers;\n        _this.reducerFactory = reducerFactory;\n        return _this;\n    }\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n    ReducerManager.prototype.addFeature = function (_a) {\n        var reducers = _a.reducers, reducerFactory = _a.reducerFactory, metaReducers = _a.metaReducers, initialState = _a.initialState, key = _a.key;\n        var /** @type {?} */ reducer = typeof reducers === 'function'\n            ? function (state, action) {\n                if (state === void 0) { state = initialState; }\n                return reducers(state, action);\n            }\n            : createReducerFactory(reducerFactory, metaReducers)(reducers, initialState);\n        this.addReducer(key, reducer);\n    };\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n    ReducerManager.prototype.removeFeature = function (_a) {\n        var key = _a.key;\n        this.removeReducer(key);\n    };\n    /**\n     * @param {?} key\n     * @param {?} reducer\n     * @return {?}\n     */\n    ReducerManager.prototype.addReducer = function (key, reducer) {\n        this.reducers = Object.assign({}, this.reducers, (_a = {}, _a[key] = reducer, _a));\n        this.updateReducers();\n        var _a;\n    };\n    /**\n     * @param {?} key\n     * @return {?}\n     */\n    ReducerManager.prototype.removeReducer = function (key) {\n        this.reducers = omit(this.reducers, key);\n        this.updateReducers();\n    };\n    /**\n     * @return {?}\n     */\n    ReducerManager.prototype.updateReducers = function () {\n        this.next(this.reducerFactory(this.reducers, this.initialState));\n        this.dispatcher.next({ type: UPDATE });\n    };\n    /**\n     * @return {?}\n     */\n    ReducerManager.prototype.ngOnDestroy = function () {\n        this.complete();\n    };\n    return ReducerManager;\n}(BehaviorSubject));\nReducerManager.decorators = [\n    { type: Injectable },\n];\n/**\n * @nocollapse\n */\nReducerManager.ctorParameters = function () { return [\n    { type: ReducerManagerDispatcher, },\n    { type: undefined, decorators: [{ type: Inject, args: [INITIAL_STATE,] },] },\n    { type: undefined, decorators: [{ type: Inject, args: [INITIAL_REDUCERS,] },] },\n    { type: undefined, decorators: [{ type: Inject, args: [REDUCER_FACTORY,] },] },\n]; };\nvar REDUCER_MANAGER_PROVIDERS = [\n    ReducerManager,\n    { provide: ReducerObservable, useExisting: ReducerManager },\n    { provide: ReducerManagerDispatcher, useExisting: ActionsSubject },\n];\nvar ScannedActionsSubject = (function (_super) {\n    __extends(ScannedActionsSubject, _super);\n    function ScannedActionsSubject() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @return {?}\n     */\n    ScannedActionsSubject.prototype.ngOnDestroy = function () {\n        this.complete();\n    };\n    return ScannedActionsSubject;\n}(Subject));\nScannedActionsSubject.decorators = [\n    { type: Injectable },\n];\n/**\n * @nocollapse\n */\nScannedActionsSubject.ctorParameters = function () { return []; };\nvar SCANNED_ACTIONS_SUBJECT_PROVIDERS = [\n    ScannedActionsSubject,\n];\n/**\n * @abstract\n */\nvar StateObservable = (function (_super) {\n    __extends(StateObservable, _super);\n    function StateObservable() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return StateObservable;\n}(Observable));\nvar State = (function (_super) {\n    __extends(State, _super);\n    /**\n     * @param {?} actions$\n     * @param {?} reducer$\n     * @param {?} scannedActions\n     * @param {?} initialState\n     */\n    function State(actions$, reducer$, scannedActions, initialState) {\n        var _this = _super.call(this, initialState) || this;\n        var actionsOnQueue$ = observeOn.call(actions$, queue);\n        var withLatestReducer$ = withLatestFrom.call(actionsOnQueue$, reducer$);\n        var stateAndAction$ = scan.call(withLatestReducer$, reduceState, initialState);\n        _this.stateSubscription = stateAndAction$.subscribe({\n            next: function (_a) {\n                var state = _a.state, action = _a.action;\n                _this.next(state);\n                scannedActions.next(action);\n            },\n        });\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    State.prototype.ngOnDestroy = function () {\n        this.stateSubscription.unsubscribe();\n        this.complete();\n    };\n    return State;\n}(BehaviorSubject));\nState.INIT = INIT;\nState.decorators = [\n    { type: Injectable },\n];\n/**\n * @nocollapse\n */\nState.ctorParameters = function () { return [\n    { type: ActionsSubject, },\n    { type: ReducerObservable, },\n    { type: ScannedActionsSubject, },\n    { type: undefined, decorators: [{ type: Inject, args: [INITIAL_STATE,] },] },\n]; };\n/**\n * @template T, V\n * @param {?=} stateActionPair\n * @param {?=} __1\n * @return {?}\n */\nfunction reduceState(stateActionPair, _a) {\n    if (stateActionPair === void 0) { stateActionPair = { state: undefined }; }\n    var action = _a[0], reducer = _a[1];\n    var state = stateActionPair.state;\n    return { state: reducer(state, action), action: action };\n}\nvar STATE_PROVIDERS = [\n    State,\n    { provide: StateObservable, useExisting: State },\n];\nvar Store = (function (_super) {\n    __extends(Store, _super);\n    /**\n     * @param {?} state$\n     * @param {?} actionsObserver\n     * @param {?} reducerManager\n     */\n    function Store(state$, actionsObserver, reducerManager) {\n        var _this = _super.call(this) || this;\n        _this.actionsObserver = actionsObserver;\n        _this.reducerManager = reducerManager;\n        _this.source = state$;\n        return _this;\n    }\n    /**\n     * @param {?} pathOrMapFn\n     * @param {...?} paths\n     * @return {?}\n     */\n    Store.prototype.select = function (pathOrMapFn) {\n        var paths = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            paths[_i - 1] = arguments[_i];\n        }\n        var /** @type {?} */ mapped$;\n        if (typeof pathOrMapFn === 'string') {\n            mapped$ = pluck.call.apply(pluck, [this, pathOrMapFn].concat(paths));\n        }\n        else if (typeof pathOrMapFn === 'function') {\n            mapped$ = map.call(this, pathOrMapFn);\n        }\n        else {\n            throw new TypeError(\"Unexpected type '\" + typeof pathOrMapFn + \"' in select operator,\" +\n                \" expected 'string' or 'function'\");\n        }\n        return distinctUntilChanged.call(mapped$);\n    };\n    /**\n     * @template R\n     * @param {?} operator\n     * @return {?}\n     */\n    Store.prototype.lift = function (operator) {\n        var /** @type {?} */ store = new Store(this, this.actionsObserver, this.reducerManager);\n        store.operator = operator;\n        return store;\n    };\n    /**\n     * @template V\n     * @param {?} action\n     * @return {?}\n     */\n    Store.prototype.dispatch = function (action) {\n        this.actionsObserver.next(action);\n    };\n    /**\n     * @param {?} action\n     * @return {?}\n     */\n    Store.prototype.next = function (action) {\n        this.actionsObserver.next(action);\n    };\n    /**\n     * @param {?} err\n     * @return {?}\n     */\n    Store.prototype.error = function (err) {\n        this.actionsObserver.error(err);\n    };\n    /**\n     * @return {?}\n     */\n    Store.prototype.complete = function () {\n        this.actionsObserver.complete();\n    };\n    /**\n     * @template State, Actions\n     * @param {?} key\n     * @param {?} reducer\n     * @return {?}\n     */\n    Store.prototype.addReducer = function (key, reducer) {\n        this.reducerManager.addReducer(key, reducer);\n    };\n    /**\n     * @template Key\n     * @param {?} key\n     * @return {?}\n     */\n    Store.prototype.removeReducer = function (key) {\n        this.reducerManager.removeReducer(key);\n    };\n    return Store;\n}(Observable));\nStore.decorators = [\n    { type: Injectable },\n];\n/**\n * @nocollapse\n */\nStore.ctorParameters = function () { return [\n    { type: StateObservable, },\n    { type: ActionsSubject, },\n    { type: ReducerManager, },\n]; };\nvar STORE_PROVIDERS = [Store];\nvar StoreRootModule = (function () {\n    /**\n     * @param {?} actions$\n     * @param {?} reducer$\n     * @param {?} scannedActions$\n     */\n    function StoreRootModule(actions$, reducer$, scannedActions$) {\n    }\n    return StoreRootModule;\n}());\nStoreRootModule.decorators = [\n    { type: NgModule, args: [{},] },\n];\n/**\n * @nocollapse\n */\nStoreRootModule.ctorParameters = function () { return [\n    { type: ActionsSubject, },\n    { type: ReducerObservable, },\n    { type: ScannedActionsSubject, },\n]; };\nvar StoreFeatureModule = (function () {\n    /**\n     * @param {?} features\n     * @param {?} featureReducers\n     * @param {?} reducerManager\n     */\n    function StoreFeatureModule(features, featureReducers, reducerManager) {\n        this.features = features;\n        this.featureReducers = featureReducers;\n        this.reducerManager = reducerManager;\n        features\n            .map(function (feature, index) {\n            var featureReducerCollection = featureReducers.shift();\n            var reducers = featureReducerCollection[index];\n            return Object.assign({}, feature, { reducers: reducers, initialState: _initialStateFactory(feature.initialState) });\n        })\n            .forEach(function (feature) { return reducerManager.addFeature(feature); });\n    }\n    /**\n     * @return {?}\n     */\n    StoreFeatureModule.prototype.ngOnDestroy = function () {\n        var _this = this;\n        this.features.forEach(function (feature) { return _this.reducerManager.removeFeature(feature); });\n    };\n    return StoreFeatureModule;\n}());\nStoreFeatureModule.decorators = [\n    { type: NgModule, args: [{},] },\n];\n/**\n * @nocollapse\n */\nStoreFeatureModule.ctorParameters = function () { return [\n    { type: Array, decorators: [{ type: Inject, args: [STORE_FEATURES,] },] },\n    { type: Array, decorators: [{ type: Inject, args: [FEATURE_REDUCERS,] },] },\n    { type: ReducerManager, },\n]; };\nvar StoreModule = (function () {\n    function StoreModule() {\n    }\n    /**\n     * @param {?} reducers\n     * @param {?=} config\n     * @return {?}\n     */\n    StoreModule.forRoot = function (reducers, config) {\n        if (config === void 0) { config = {}; }\n        return {\n            ngModule: StoreRootModule,\n            providers: [\n                { provide: _INITIAL_STATE, useValue: config.initialState },\n                {\n                    provide: INITIAL_STATE,\n                    useFactory: _initialStateFactory,\n                    deps: [_INITIAL_STATE],\n                },\n                { provide: _INITIAL_REDUCERS, useValue: reducers },\n                {\n                    provide: _STORE_REDUCERS,\n                    useExisting: reducers instanceof InjectionToken ? reducers : _INITIAL_REDUCERS,\n                },\n                {\n                    provide: INITIAL_REDUCERS,\n                    deps: [Injector, _INITIAL_REDUCERS, [new Inject(_STORE_REDUCERS)]],\n                    useFactory: _createStoreReducers,\n                },\n                {\n                    provide: META_REDUCERS,\n                    useValue: config.metaReducers ? config.metaReducers : [],\n                },\n                {\n                    provide: _REDUCER_FACTORY,\n                    useValue: config.reducerFactory\n                        ? config.reducerFactory\n                        : combineReducers,\n                },\n                {\n                    provide: REDUCER_FACTORY,\n                    deps: [_REDUCER_FACTORY, META_REDUCERS],\n                    useFactory: createReducerFactory,\n                },\n                ACTIONS_SUBJECT_PROVIDERS,\n                REDUCER_MANAGER_PROVIDERS,\n                SCANNED_ACTIONS_SUBJECT_PROVIDERS,\n                STATE_PROVIDERS,\n                STORE_PROVIDERS,\n            ],\n        };\n    };\n    /**\n     * @param {?} featureName\n     * @param {?} reducers\n     * @param {?=} config\n     * @return {?}\n     */\n    StoreModule.forFeature = function (featureName, reducers, config) {\n        if (config === void 0) { config = {}; }\n        return {\n            ngModule: StoreFeatureModule,\n            providers: [\n                {\n                    provide: STORE_FEATURES,\n                    multi: true,\n                    useValue: /** @type {?} */ ({\n                        key: featureName,\n                        reducerFactory: config.reducerFactory\n                            ? config.reducerFactory\n                            : combineReducers,\n                        metaReducers: config.metaReducers ? config.metaReducers : [],\n                        initialState: config.initialState,\n                    }),\n                },\n                { provide: _FEATURE_REDUCERS, multi: true, useValue: reducers },\n                {\n                    provide: _FEATURE_REDUCERS_TOKEN,\n                    multi: true,\n                    useExisting: reducers instanceof InjectionToken ? reducers : _FEATURE_REDUCERS,\n                },\n                {\n                    provide: FEATURE_REDUCERS,\n                    multi: true,\n                    deps: [\n                        Injector,\n                        _FEATURE_REDUCERS,\n                        [new Inject(_FEATURE_REDUCERS_TOKEN)],\n                    ],\n                    useFactory: _createFeatureReducers,\n                },\n            ],\n        };\n    };\n    return StoreModule;\n}());\nStoreModule.decorators = [\n    { type: NgModule, args: [{},] },\n];\n/**\n * @nocollapse\n */\nStoreModule.ctorParameters = function () { return []; };\n/**\n * @param {?} injector\n * @param {?} reducers\n * @param {?} tokenReducers\n * @return {?}\n */\nfunction _createStoreReducers(injector, reducers, tokenReducers) {\n    return reducers instanceof InjectionToken ? injector.get(reducers) : reducers;\n}\n/**\n * @param {?} injector\n * @param {?} reducerCollection\n * @param {?} tokenReducerCollection\n * @return {?}\n */\nfunction _createFeatureReducers(injector, reducerCollection, tokenReducerCollection) {\n    return reducerCollection.map(function (reducer, index) {\n        return reducer instanceof InjectionToken ? injector.get(reducer) : reducer;\n    });\n}\n/**\n * @param {?} initialState\n * @return {?}\n */\nfunction _initialStateFactory(initialState) {\n    if (typeof initialState === 'function') {\n        return initialState();\n    }\n    return initialState;\n}\n/**\n * @param {?} t\n * @return {?}\n */\nfunction memoize(t) {\n    var /** @type {?} */ lastArguments = null;\n    var /** @type {?} */ lastResult = null;\n    /**\n     * @return {?}\n     */\n    function reset() {\n        lastArguments = null;\n        lastResult = null;\n    }\n    /**\n     * @return {?}\n     */\n    function memoized() {\n        if (!lastArguments) {\n            lastResult = t.apply(null, arguments);\n            lastArguments = arguments;\n            return lastResult;\n        }\n        for (var /** @type {?} */ i = 0; i < arguments.length; i++) {\n            if (arguments[i] !== lastArguments[i]) {\n                lastResult = t.apply(null, arguments);\n                lastArguments = arguments;\n                return lastResult;\n            }\n        }\n        return lastResult;\n    }\n    return { memoized: memoized, reset: reset };\n}\n/**\n * @param {...?} args\n * @return {?}\n */\nfunction createSelector() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var /** @type {?} */ selectors = args.slice(0, args.length - 1);\n    var /** @type {?} */ projector = args[args.length - 1];\n    var /** @type {?} */ memoizedSelectors = selectors.filter(function (selector) { return selector.release && typeof selector.release === 'function'; });\n    var /** @type {?} */ memoizedProjector = memoize(function () {\n        var selectors = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            selectors[_i] = arguments[_i];\n        }\n        return projector.apply(null, selectors);\n    });\n    var /** @type {?} */ memoizedState = memoize(function (state) {\n        var /** @type {?} */ args = selectors.map(function (fn) { return fn(state); });\n        return memoizedProjector.memoized.apply(null, args);\n    });\n    /**\n     * @return {?}\n     */\n    function release() {\n        memoizedState.reset();\n        memoizedProjector.reset();\n        memoizedSelectors.forEach(function (selector) { return selector.release(); });\n    }\n    return Object.assign(memoizedState.memoized, { release: release });\n}\n/**\n * @template T\n * @param {?} featureName\n * @return {?}\n */\nfunction createFeatureSelector(featureName) {\n    var _a = memoize(function (state) {\n        return state[featureName];\n    }), memoized = _a.memoized, reset = _a.reset;\n    return Object.assign(memoized, { release: reset });\n}\n/**\n * Generated bundle index. Do not edit.\n */\nexport { StoreModule, Store, combineReducers, compose, createReducerFactory, ActionsSubject, INIT, ReducerManager, ReducerObservable, ReducerManagerDispatcher, UPDATE, ScannedActionsSubject, createSelector, createFeatureSelector, State, StateObservable, reduceState, INITIAL_STATE, _REDUCER_FACTORY, REDUCER_FACTORY, _INITIAL_REDUCERS, INITIAL_REDUCERS, STORE_FEATURES, _INITIAL_STATE, META_REDUCERS, _STORE_REDUCERS, _FEATURE_REDUCERS, FEATURE_REDUCERS, _FEATURE_REDUCERS_TOKEN, StoreRootModule, StoreFeatureModule, _initialStateFactory, _createStoreReducers, _createFeatureReducers, ACTIONS_SUBJECT_PROVIDERS as ɵc, REDUCER_MANAGER_PROVIDERS as ɵd, SCANNED_ACTIONS_SUBJECT_PROVIDERS as ɵe, STATE_PROVIDERS as ɵf, STORE_PROVIDERS as ɵb };\n//# sourceMappingURL=store.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/@ngrx/store/@ngrx/store.es5.js\n// module id = ../../../../@ngrx/store/@ngrx/store.es5.js\n// module chunks = common","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/css-loader/lib/css-base.js\n// module id = ../../../../css-loader/lib/css-base.js\n// module chunks = styles common","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('./Subject');\nvar queue_1 = require('./scheduler/queue');\nvar Subscription_1 = require('./Subscription');\nvar observeOn_1 = require('./operator/observeOn');\nvar ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');\nvar SubjectSubscription_1 = require('./SubjectSubscription');\n/**\n * @class ReplaySubject<T>\n */\nvar ReplaySubject = (function (_super) {\n    __extends(ReplaySubject, _super);\n    function ReplaySubject(bufferSize, windowTime, scheduler) {\n        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }\n        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }\n        _super.call(this);\n        this.scheduler = scheduler;\n        this._events = [];\n        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n        this._windowTime = windowTime < 1 ? 1 : windowTime;\n    }\n    ReplaySubject.prototype.next = function (value) {\n        var now = this._getNow();\n        this._events.push(new ReplayEvent(now, value));\n        this._trimBufferThenGetEvents();\n        _super.prototype.next.call(this, value);\n    };\n    ReplaySubject.prototype._subscribe = function (subscriber) {\n        var _events = this._trimBufferThenGetEvents();\n        var scheduler = this.scheduler;\n        var subscription;\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else if (this.hasError) {\n            subscription = Subscription_1.Subscription.EMPTY;\n        }\n        else if (this.isStopped) {\n            subscription = Subscription_1.Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n        }\n        if (scheduler) {\n            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));\n        }\n        var len = _events.length;\n        for (var i = 0; i < len && !subscriber.closed; i++) {\n            subscriber.next(_events[i].value);\n        }\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n        }\n        return subscription;\n    };\n    ReplaySubject.prototype._getNow = function () {\n        return (this.scheduler || queue_1.queue).now();\n    };\n    ReplaySubject.prototype._trimBufferThenGetEvents = function () {\n        var now = this._getNow();\n        var _bufferSize = this._bufferSize;\n        var _windowTime = this._windowTime;\n        var _events = this._events;\n        var eventsCount = _events.length;\n        var spliceCount = 0;\n        // Trim events that fall out of the time window.\n        // Start at the front of the list. Break early once\n        // we encounter an event that falls within the window.\n        while (spliceCount < eventsCount) {\n            if ((now - _events[spliceCount].time) < _windowTime) {\n                break;\n            }\n            spliceCount++;\n        }\n        if (eventsCount > _bufferSize) {\n            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n        }\n        if (spliceCount > 0) {\n            _events.splice(0, spliceCount);\n        }\n        return _events;\n    };\n    return ReplaySubject;\n}(Subject_1.Subject));\nexports.ReplaySubject = ReplaySubject;\nvar ReplayEvent = (function () {\n    function ReplayEvent(time, value) {\n        this.time = time;\n        this.value = value;\n    }\n    return ReplayEvent;\n}());\n//# sourceMappingURL=ReplaySubject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/ReplaySubject.js\n// module id = ../../../../rxjs/ReplaySubject.js\n// module chunks = common","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar catch_1 = require('../../operator/catch');\nObservable_1.Observable.prototype.catch = catch_1._catch;\nObservable_1.Observable.prototype._catch = catch_1._catch;\n//# sourceMappingURL=catch.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/add/operator/catch.js\n// module id = ../../../../rxjs/add/operator/catch.js\n// module chunks = common","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar debounceTime_1 = require('../../operator/debounceTime');\nObservable_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime;\n//# sourceMappingURL=debounceTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/add/operator/debounceTime.js\n// module id = ../../../../rxjs/add/operator/debounceTime.js\n// module chunks = common","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar distinctUntilChanged_1 = require('../../operator/distinctUntilChanged');\nObservable_1.Observable.prototype.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;\n//# sourceMappingURL=distinctUntilChanged.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/add/operator/distinctUntilChanged.js\n// module id = ../../../../rxjs/add/operator/distinctUntilChanged.js\n// module chunks = common","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar mergeMap_1 = require('../../operator/mergeMap');\nObservable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;\nObservable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;\n//# sourceMappingURL=mergeMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/add/operator/mergeMap.js\n// module id = ../../../../rxjs/add/operator/mergeMap.js\n// module chunks = common","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar switchMap_1 = require('../../operator/switchMap');\nObservable_1.Observable.prototype.switchMap = switchMap_1.switchMap;\n//# sourceMappingURL=switchMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/add/operator/switchMap.js\n// module id = ../../../../rxjs/add/operator/switchMap.js\n// module chunks = common","\"use strict\";\nvar EmptyObservable_1 = require('./EmptyObservable');\nexports.empty = EmptyObservable_1.EmptyObservable.create;\n//# sourceMappingURL=empty.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/observable/empty.js\n// module id = ../../../../rxjs/observable/empty.js\n// module chunks = common","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Converts an Observable of {@link Notification} objects into the emissions\n * that they represent.\n *\n * <span class=\"informal\">Unwraps {@link Notification} objects as actual `next`,\n * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\n *\n * <img src=\"./img/dematerialize.png\" width=\"100%\">\n *\n * `dematerialize` is assumed to operate an Observable that only emits\n * {@link Notification} objects as `next` emissions, and does not emit any\n * `error`. Such Observable is the output of a `materialize` operation. Those\n * notifications are then unwrapped using the metadata they contain, and emitted\n * as `next`, `error`, and `complete` on the output Observable.\n *\n * Use this operator in conjunction with {@link materialize}.\n *\n * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>\n * var notifA = new Rx.Notification('N', 'A');\n * var notifB = new Rx.Notification('N', 'B');\n * var notifE = new Rx.Notification('E', void 0,\n *   new TypeError('x.toUpperCase is not a function')\n * );\n * var materialized = Rx.Observable.of(notifA, notifB, notifE);\n * var upperCase = materialized.dematerialize();\n * upperCase.subscribe(x => console.log(x), e => console.error(e));\n *\n * // Results in:\n * // A\n * // B\n * // TypeError: x.toUpperCase is not a function\n *\n * @see {@link Notification}\n * @see {@link materialize}\n *\n * @return {Observable} An Observable that emits items and notifications\n * embedded in Notification objects emitted by the source Observable.\n * @method dematerialize\n * @owner Observable\n */\nfunction dematerialize() {\n    return this.lift(new DeMaterializeOperator());\n}\nexports.dematerialize = dematerialize;\nvar DeMaterializeOperator = (function () {\n    function DeMaterializeOperator() {\n    }\n    DeMaterializeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DeMaterializeSubscriber(subscriber));\n    };\n    return DeMaterializeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DeMaterializeSubscriber = (function (_super) {\n    __extends(DeMaterializeSubscriber, _super);\n    function DeMaterializeSubscriber(destination) {\n        _super.call(this, destination);\n    }\n    DeMaterializeSubscriber.prototype._next = function (value) {\n        value.observe(this.destination);\n    };\n    return DeMaterializeSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=dematerialize.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/operator/dematerialize.js\n// module id = ../../../../rxjs/operator/dematerialize.js\n// module chunks = common","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * @example <caption>A simple example with numbers</caption>\n * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)\n *   .distinctUntilChanged()\n *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4\n *\n * @example <caption>An example using a compare function</caption>\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'})\n *     { age: 6, name: 'Foo'})\n *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n *\n * @see {@link distinct}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinctUntilChanged\n * @owner Observable\n */\nfunction distinctUntilChanged(compare, keySelector) {\n    return this.lift(new DistinctUntilChangedOperator(compare, keySelector));\n}\nexports.distinctUntilChanged = distinctUntilChanged;\nvar DistinctUntilChangedOperator = (function () {\n    function DistinctUntilChangedOperator(compare, keySelector) {\n        this.compare = compare;\n        this.keySelector = keySelector;\n    }\n    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));\n    };\n    return DistinctUntilChangedOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DistinctUntilChangedSubscriber = (function (_super) {\n    __extends(DistinctUntilChangedSubscriber, _super);\n    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {\n        _super.call(this, destination);\n        this.keySelector = keySelector;\n        this.hasKey = false;\n        if (typeof compare === 'function') {\n            this.compare = compare;\n        }\n    }\n    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {\n        return x === y;\n    };\n    DistinctUntilChangedSubscriber.prototype._next = function (value) {\n        var keySelector = this.keySelector;\n        var key = value;\n        if (keySelector) {\n            key = tryCatch_1.tryCatch(this.keySelector)(value);\n            if (key === errorObject_1.errorObject) {\n                return this.destination.error(errorObject_1.errorObject.e);\n            }\n        }\n        var result = false;\n        if (this.hasKey) {\n            result = tryCatch_1.tryCatch(this.compare)(this.key, key);\n            if (result === errorObject_1.errorObject) {\n                return this.destination.error(errorObject_1.errorObject.e);\n            }\n        }\n        else {\n            this.hasKey = true;\n        }\n        if (Boolean(result) === false) {\n            this.key = key;\n            this.destination.next(value);\n        }\n    };\n    return DistinctUntilChangedSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=distinctUntilChanged.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/operator/distinctUntilChanged.js\n// module id = ../../../../rxjs/operator/distinctUntilChanged.js\n// module chunks = common","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n * @method exhaustMap\n * @owner Observable\n */\nfunction exhaustMap(project, resultSelector) {\n    return this.lift(new SwitchFirstMapOperator(project, resultSelector));\n}\nexports.exhaustMap = exhaustMap;\nvar SwitchFirstMapOperator = (function () {\n    function SwitchFirstMapOperator(project, resultSelector) {\n        this.project = project;\n        this.resultSelector = resultSelector;\n    }\n    SwitchFirstMapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));\n    };\n    return SwitchFirstMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchFirstMapSubscriber = (function (_super) {\n    __extends(SwitchFirstMapSubscriber, _super);\n    function SwitchFirstMapSubscriber(destination, project, resultSelector) {\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.hasSubscription = false;\n        this.hasCompleted = false;\n        this.index = 0;\n    }\n    SwitchFirstMapSubscriber.prototype._next = function (value) {\n        if (!this.hasSubscription) {\n            this.tryNext(value);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {\n        var index = this.index++;\n        var destination = this.destination;\n        try {\n            var result = this.project(value, index);\n            this.hasSubscription = true;\n            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n        }\n        catch (err) {\n            destination.error(err);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (!this.hasSubscription) {\n            this.destination.complete();\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        try {\n            var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n            destination.next(result);\n        }\n        catch (err) {\n            destination.error(err);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {\n        this.destination.error(err);\n    };\n    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.hasSubscription = false;\n        if (this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return SwitchFirstMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=exhaustMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/operator/exhaustMap.js\n// module id = ../../../../rxjs/operator/exhaustMap.js\n// module chunks = common","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar Subscription_1 = require('../Subscription');\nvar Observable_1 = require('../Observable');\nvar Subject_1 = require('../Subject');\nvar Map_1 = require('../util/Map');\nvar FastMap_1 = require('../util/FastMap');\n/* tslint:enable:max-line-length */\n/**\n * Groups the items emitted by an Observable according to a specified criterion,\n * and emits these grouped items as `GroupedObservables`, one\n * {@link GroupedObservable} per group.\n *\n * <img src=\"./img/groupBy.png\" width=\"100%\">\n *\n * @example <caption>Group objects by id and return as array</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs3'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *     )\n *     .groupBy(p => p.id)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // [ { id: 1, name: 'aze1' },\n * //   { id: 1, name: 'erg1' },\n * //   { id: 1, name: 'df1' } ]\n * //\n * // [ { id: 2, name: 'sf2' },\n * //   { id: 2, name: 'dg2' },\n * //   { id: 2, name: 'sfqfb2' },\n * //   { id: 2, name: 'qsgqsfg2' } ]\n * //\n * // [ { id: 3, name: 'qfs3' } ]\n *\n * @example <caption>Pivot data on the id field</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs1'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *                   )\n *     .groupBy(p => p.id, p => p.name)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], [\"\" + group$.key]))\n *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }\n * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }\n * // { id: 3, values: [ 'qfs1' ] }\n *\n * @param {function(value: T): K} keySelector A function that extracts the key\n * for each item.\n * @param {function(value: T): R} [elementSelector] A function that extracts the\n * return element for each item.\n * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]\n * A function that returns an Observable to determine how long each group should\n * exist.\n * @return {Observable<GroupedObservable<K,R>>} An Observable that emits\n * GroupedObservables, each of which corresponds to a unique key value and each\n * of which emits those items from the source Observable that share that key\n * value.\n * @method groupBy\n * @owner Observable\n */\nfunction groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {\n    return this.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));\n}\nexports.groupBy = groupBy;\nvar GroupByOperator = (function () {\n    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {\n        this.keySelector = keySelector;\n        this.elementSelector = elementSelector;\n        this.durationSelector = durationSelector;\n        this.subjectSelector = subjectSelector;\n    }\n    GroupByOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));\n    };\n    return GroupByOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar GroupBySubscriber = (function (_super) {\n    __extends(GroupBySubscriber, _super);\n    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {\n        _super.call(this, destination);\n        this.keySelector = keySelector;\n        this.elementSelector = elementSelector;\n        this.durationSelector = durationSelector;\n        this.subjectSelector = subjectSelector;\n        this.groups = null;\n        this.attemptedToUnsubscribe = false;\n        this.count = 0;\n    }\n    GroupBySubscriber.prototype._next = function (value) {\n        var key;\n        try {\n            key = this.keySelector(value);\n        }\n        catch (err) {\n            this.error(err);\n            return;\n        }\n        this._group(value, key);\n    };\n    GroupBySubscriber.prototype._group = function (value, key) {\n        var groups = this.groups;\n        if (!groups) {\n            groups = this.groups = typeof key === 'string' ? new FastMap_1.FastMap() : new Map_1.Map();\n        }\n        var group = groups.get(key);\n        var element;\n        if (this.elementSelector) {\n            try {\n                element = this.elementSelector(value);\n            }\n            catch (err) {\n                this.error(err);\n            }\n        }\n        else {\n            element = value;\n        }\n        if (!group) {\n            group = this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject();\n            groups.set(key, group);\n            var groupedObservable = new GroupedObservable(key, group, this);\n            this.destination.next(groupedObservable);\n            if (this.durationSelector) {\n                var duration = void 0;\n                try {\n                    duration = this.durationSelector(new GroupedObservable(key, group));\n                }\n                catch (err) {\n                    this.error(err);\n                    return;\n                }\n                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));\n            }\n        }\n        if (!group.closed) {\n            group.next(element);\n        }\n    };\n    GroupBySubscriber.prototype._error = function (err) {\n        var groups = this.groups;\n        if (groups) {\n            groups.forEach(function (group, key) {\n                group.error(err);\n            });\n            groups.clear();\n        }\n        this.destination.error(err);\n    };\n    GroupBySubscriber.prototype._complete = function () {\n        var groups = this.groups;\n        if (groups) {\n            groups.forEach(function (group, key) {\n                group.complete();\n            });\n            groups.clear();\n        }\n        this.destination.complete();\n    };\n    GroupBySubscriber.prototype.removeGroup = function (key) {\n        this.groups.delete(key);\n    };\n    GroupBySubscriber.prototype.unsubscribe = function () {\n        if (!this.closed) {\n            this.attemptedToUnsubscribe = true;\n            if (this.count === 0) {\n                _super.prototype.unsubscribe.call(this);\n            }\n        }\n    };\n    return GroupBySubscriber;\n}(Subscriber_1.Subscriber));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar GroupDurationSubscriber = (function (_super) {\n    __extends(GroupDurationSubscriber, _super);\n    function GroupDurationSubscriber(key, group, parent) {\n        _super.call(this, group);\n        this.key = key;\n        this.group = group;\n        this.parent = parent;\n    }\n    GroupDurationSubscriber.prototype._next = function (value) {\n        this.complete();\n    };\n    GroupDurationSubscriber.prototype._unsubscribe = function () {\n        var _a = this, parent = _a.parent, key = _a.key;\n        this.key = this.parent = null;\n        if (parent) {\n            parent.removeGroup(key);\n        }\n    };\n    return GroupDurationSubscriber;\n}(Subscriber_1.Subscriber));\n/**\n * An Observable representing values belonging to the same group represented by\n * a common key. The values emitted by a GroupedObservable come from the source\n * Observable. The common key is available as the field `key` on a\n * GroupedObservable instance.\n *\n * @class GroupedObservable<K, T>\n */\nvar GroupedObservable = (function (_super) {\n    __extends(GroupedObservable, _super);\n    function GroupedObservable(key, groupSubject, refCountSubscription) {\n        _super.call(this);\n        this.key = key;\n        this.groupSubject = groupSubject;\n        this.refCountSubscription = refCountSubscription;\n    }\n    GroupedObservable.prototype._subscribe = function (subscriber) {\n        var subscription = new Subscription_1.Subscription();\n        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;\n        if (refCountSubscription && !refCountSubscription.closed) {\n            subscription.add(new InnerRefCountSubscription(refCountSubscription));\n        }\n        subscription.add(groupSubject.subscribe(subscriber));\n        return subscription;\n    };\n    return GroupedObservable;\n}(Observable_1.Observable));\nexports.GroupedObservable = GroupedObservable;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar InnerRefCountSubscription = (function (_super) {\n    __extends(InnerRefCountSubscription, _super);\n    function InnerRefCountSubscription(parent) {\n        _super.call(this);\n        this.parent = parent;\n        parent.count++;\n    }\n    InnerRefCountSubscription.prototype.unsubscribe = function () {\n        var parent = this.parent;\n        if (!parent.closed && !this.closed) {\n            _super.prototype.unsubscribe.call(this);\n            parent.count -= 1;\n            if (parent.count === 0 && parent.attemptedToUnsubscribe) {\n                parent.unsubscribe();\n            }\n        }\n    };\n    return InnerRefCountSubscription;\n}(Subscription_1.Subscription));\n//# sourceMappingURL=groupBy.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/operator/groupBy.js\n// module id = ../../../../rxjs/operator/groupBy.js\n// module chunks = common","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar noop_1 = require('../util/noop');\n/**\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n *\n * <img src=\"./img/ignoreElements.png\" width=\"100%\">\n *\n * @return {Observable} An empty Observable that only calls `complete`\n * or `error`, based on which one is called by the source Observable.\n * @method ignoreElements\n * @owner Observable\n */\nfunction ignoreElements() {\n    return this.lift(new IgnoreElementsOperator());\n}\nexports.ignoreElements = ignoreElements;\n;\nvar IgnoreElementsOperator = (function () {\n    function IgnoreElementsOperator() {\n    }\n    IgnoreElementsOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new IgnoreElementsSubscriber(subscriber));\n    };\n    return IgnoreElementsOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar IgnoreElementsSubscriber = (function (_super) {\n    __extends(IgnoreElementsSubscriber, _super);\n    function IgnoreElementsSubscriber() {\n        _super.apply(this, arguments);\n    }\n    IgnoreElementsSubscriber.prototype._next = function (unused) {\n        noop_1.noop();\n    };\n    return IgnoreElementsSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=ignoreElements.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/operator/ignoreElements.js\n// module id = ../../../../rxjs/operator/ignoreElements.js\n// module chunks = common","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar Notification_1 = require('../Notification');\n/**\n * Represents all of the notifications from the source Observable as `next`\n * emissions marked with their original types within {@link Notification}\n * objects.\n *\n * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n * {@link Notification} objects, emitted as `next` on the output Observable.\n * </span>\n *\n * <img src=\"./img/materialize.png\" width=\"100%\">\n *\n * `materialize` returns an Observable that emits a `next` notification for each\n * `next`, `error`, or `complete` emission of the source Observable. When the\n * source Observable emits `complete`, the output Observable will emit `next` as\n * a Notification of type \"complete\", and then it will emit `complete` as well.\n * When the source Observable emits `error`, the output will emit `next` as a\n * Notification of type \"error\", and then `complete`.\n *\n * This operator is useful for producing metadata of the source Observable, to\n * be consumed as `next` emissions. Use it in conjunction with\n * {@link dematerialize}.\n *\n * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>\n * var letters = Rx.Observable.of('a', 'b', 13, 'd');\n * var upperCase = letters.map(x => x.toUpperCase());\n * var materialized = upperCase.materialize();\n * materialized.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - Notification {kind: \"N\", value: \"A\", error: undefined, hasValue: true}\n * // - Notification {kind: \"N\", value: \"B\", error: undefined, hasValue: true}\n * // - Notification {kind: \"E\", value: undefined, error: TypeError:\n * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x\n * //   [as project] (http://1…, hasValue: false}\n *\n * @see {@link Notification}\n * @see {@link dematerialize}\n *\n * @return {Observable<Notification<T>>} An Observable that emits\n * {@link Notification} objects that wrap the original emissions from the source\n * Observable with metadata.\n * @method materialize\n * @owner Observable\n */\nfunction materialize() {\n    return this.lift(new MaterializeOperator());\n}\nexports.materialize = materialize;\nvar MaterializeOperator = (function () {\n    function MaterializeOperator() {\n    }\n    MaterializeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MaterializeSubscriber(subscriber));\n    };\n    return MaterializeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MaterializeSubscriber = (function (_super) {\n    __extends(MaterializeSubscriber, _super);\n    function MaterializeSubscriber(destination) {\n        _super.call(this, destination);\n    }\n    MaterializeSubscriber.prototype._next = function (value) {\n        this.destination.next(Notification_1.Notification.createNext(value));\n    };\n    MaterializeSubscriber.prototype._error = function (err) {\n        var destination = this.destination;\n        destination.next(Notification_1.Notification.createError(err));\n        destination.complete();\n    };\n    MaterializeSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        destination.next(Notification_1.Notification.createComplete());\n        destination.complete();\n    };\n    return MaterializeSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=materialize.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/operator/materialize.js\n// module id = ../../../../rxjs/operator/materialize.js\n// module chunks = common","\"use strict\";\nvar map_1 = require('./map');\n/**\n * Maps each source value (an object) to its specified nested property.\n *\n * <span class=\"informal\">Like {@link map}, but meant only for picking one of\n * the nested properties of every emitted object.</span>\n *\n * <img src=\"./img/pluck.png\" width=\"100%\">\n *\n * Given a list of strings describing a path to an object property, retrieves\n * the value of a specified nested property from all values in the source\n * Observable. If a property can't be resolved, it will return `undefined` for\n * that value.\n *\n * @example <caption>Map every click to the tagName of the clicked target element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var tagNames = clicks.pluck('target', 'tagName');\n * tagNames.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {...string} properties The nested properties to pluck from each source\n * value (an object).\n * @return {Observable} A new Observable of property values from the source values.\n * @method pluck\n * @owner Observable\n */\nfunction pluck() {\n    var properties = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        properties[_i - 0] = arguments[_i];\n    }\n    var length = properties.length;\n    if (length === 0) {\n        throw new Error('list of properties cannot be empty.');\n    }\n    return map_1.map.call(this, plucker(properties, length));\n}\nexports.pluck = pluck;\nfunction plucker(props, length) {\n    var mapper = function (x) {\n        var currentProp = x;\n        for (var i = 0; i < length; i++) {\n            var p = currentProp[props[i]];\n            if (typeof p !== 'undefined') {\n                currentProp = p;\n            }\n            else {\n                return undefined;\n            }\n        }\n        return currentProp;\n    };\n    return mapper;\n}\n//# sourceMappingURL=pluck.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/operator/pluck.js\n// module id = ../../../../rxjs/operator/pluck.js\n// module chunks = common","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/* tslint:enable:max-line-length */\n/**\n * Applies an accumulator function over the source Observable, and returns each\n * intermediate result, with an optional seed value.\n *\n * <span class=\"informal\">It's like {@link reduce}, but emits the current\n * accumulation whenever the source emits a value.</span>\n *\n * <img src=\"./img/scan.png\" width=\"100%\">\n *\n * Combines together all values emitted on the source, using an accumulator\n * function that knows how to join a new source value into the accumulation from\n * the past. Is similar to {@link reduce}, but emits the intermediate\n * accumulations.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var ones = clicks.mapTo(1);\n * var seed = 0;\n * var count = ones.scan((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link reduce}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator\n * The accumulator function called on each source value.\n * @param {T|R} [seed] The initial accumulation value.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method scan\n * @owner Observable\n */\nfunction scan(accumulator, seed) {\n    var hasSeed = false;\n    // providing a seed of `undefined` *should* be valid and trigger\n    // hasSeed! so don't use `seed !== undefined` checks!\n    // For this reason, we have to check it here at the original call site\n    // otherwise inside Operator/Subscriber we won't know if `undefined`\n    // means they didn't provide anything or if they literally provided `undefined`\n    if (arguments.length >= 2) {\n        hasSeed = true;\n    }\n    return this.lift(new ScanOperator(accumulator, seed, hasSeed));\n}\nexports.scan = scan;\nvar ScanOperator = (function () {\n    function ScanOperator(accumulator, seed, hasSeed) {\n        if (hasSeed === void 0) { hasSeed = false; }\n        this.accumulator = accumulator;\n        this.seed = seed;\n        this.hasSeed = hasSeed;\n    }\n    ScanOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));\n    };\n    return ScanOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ScanSubscriber = (function (_super) {\n    __extends(ScanSubscriber, _super);\n    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {\n        _super.call(this, destination);\n        this.accumulator = accumulator;\n        this._seed = _seed;\n        this.hasSeed = hasSeed;\n        this.index = 0;\n    }\n    Object.defineProperty(ScanSubscriber.prototype, \"seed\", {\n        get: function () {\n            return this._seed;\n        },\n        set: function (value) {\n            this.hasSeed = true;\n            this._seed = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ScanSubscriber.prototype._next = function (value) {\n        if (!this.hasSeed) {\n            this.seed = value;\n            this.destination.next(value);\n        }\n        else {\n            return this._tryNext(value);\n        }\n    };\n    ScanSubscriber.prototype._tryNext = function (value) {\n        var index = this.index++;\n        var result;\n        try {\n            result = this.accumulator(this.seed, value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n        this.seed = result;\n        this.destination.next(result);\n    };\n    return ScanSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=scan.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/operator/scan.js\n// module id = ../../../../rxjs/operator/scan.js\n// module chunks = common","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Returns an Observable that skips the first `count` items emitted by the source Observable.\n *\n * <img src=\"./img/skip.png\" width=\"100%\">\n *\n * @param {Number} count - The number of times, items emitted by source Observable should be skipped.\n * @return {Observable} An Observable that skips values emitted by the source Observable.\n *\n * @method skip\n * @owner Observable\n */\nfunction skip(count) {\n    return this.lift(new SkipOperator(count));\n}\nexports.skip = skip;\nvar SkipOperator = (function () {\n    function SkipOperator(total) {\n        this.total = total;\n    }\n    SkipOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SkipSubscriber(subscriber, this.total));\n    };\n    return SkipOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipSubscriber = (function (_super) {\n    __extends(SkipSubscriber, _super);\n    function SkipSubscriber(destination, total) {\n        _super.call(this, destination);\n        this.total = total;\n        this.count = 0;\n    }\n    SkipSubscriber.prototype._next = function (x) {\n        if (++this.count > this.total) {\n            this.destination.next(x);\n        }\n    };\n    return SkipSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=skip.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/operator/skip.js\n// module id = ../../../../rxjs/operator/skip.js\n// module chunks = common","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Combines the source Observable with other Observables to create an Observable\n * whose values are calculated from the latest values of each, only when the\n * source emits.\n *\n * <span class=\"informal\">Whenever the source Observable emits a value, it\n * computes a formula using that value plus the latest values from other input\n * Observables, then emits the output of that formula.</span>\n *\n * <img src=\"./img/withLatestFrom.png\" width=\"100%\">\n *\n * `withLatestFrom` combines each value from the source Observable (the\n * instance) with the latest values from the other input Observables only when\n * the source emits a value, optionally using a `project` function to determine\n * the value to be emitted on the output Observable. All input Observables must\n * emit at least one value before the output Observable will emit a value.\n *\n * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var result = clicks.withLatestFrom(timer);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineLatest}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Function} [project] Projection function for combining values\n * together. Receives all values in order of the Observables passed, where the\n * first parameter is a value from the source Observable. (e.g.\n * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not\n * passed, arrays will be emitted on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method withLatestFrom\n * @owner Observable\n */\nfunction withLatestFrom() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n    }\n    var project;\n    if (typeof args[args.length - 1] === 'function') {\n        project = args.pop();\n    }\n    var observables = args;\n    return this.lift(new WithLatestFromOperator(observables, project));\n}\nexports.withLatestFrom = withLatestFrom;\nvar WithLatestFromOperator = (function () {\n    function WithLatestFromOperator(observables, project) {\n        this.observables = observables;\n        this.project = project;\n    }\n    WithLatestFromOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));\n    };\n    return WithLatestFromOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WithLatestFromSubscriber = (function (_super) {\n    __extends(WithLatestFromSubscriber, _super);\n    function WithLatestFromSubscriber(destination, observables, project) {\n        _super.call(this, destination);\n        this.observables = observables;\n        this.project = project;\n        this.toRespond = [];\n        var len = observables.length;\n        this.values = new Array(len);\n        for (var i = 0; i < len; i++) {\n            this.toRespond.push(i);\n        }\n        for (var i = 0; i < len; i++) {\n            var observable = observables[i];\n            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));\n        }\n    }\n    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values[outerIndex] = innerValue;\n        var toRespond = this.toRespond;\n        if (toRespond.length > 0) {\n            var found = toRespond.indexOf(outerIndex);\n            if (found !== -1) {\n                toRespond.splice(found, 1);\n            }\n        }\n    };\n    WithLatestFromSubscriber.prototype.notifyComplete = function () {\n        // noop\n    };\n    WithLatestFromSubscriber.prototype._next = function (value) {\n        if (this.toRespond.length === 0) {\n            var args = [value].concat(this.values);\n            if (this.project) {\n                this._tryProject(args);\n            }\n            else {\n                this.destination.next(args);\n            }\n        }\n    };\n    WithLatestFromSubscriber.prototype._tryProject = function (args) {\n        var result;\n        try {\n            result = this.project.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return WithLatestFromSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=withLatestFrom.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/operator/withLatestFrom.js\n// module id = ../../../../rxjs/operator/withLatestFrom.js\n// module chunks = common","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncAction_1 = require('./AsyncAction');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar QueueAction = (function (_super) {\n    __extends(QueueAction, _super);\n    function QueueAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    QueueAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (delay > 0) {\n            return _super.prototype.schedule.call(this, state, delay);\n        }\n        this.delay = delay;\n        this.state = state;\n        this.scheduler.flush(this);\n        return this;\n    };\n    QueueAction.prototype.execute = function (state, delay) {\n        return (delay > 0 || this.closed) ?\n            _super.prototype.execute.call(this, state, delay) :\n            this._execute(state, delay);\n    };\n    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If delay exists and is greater than 0, or if the delay is null (the\n        // action wasn't rescheduled) but was originally scheduled as an async\n        // action, then recycle as an async action.\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        // Otherwise flush the scheduler starting with this action.\n        return scheduler.flush(this);\n    };\n    return QueueAction;\n}(AsyncAction_1.AsyncAction));\nexports.QueueAction = QueueAction;\n//# sourceMappingURL=QueueAction.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/scheduler/QueueAction.js\n// module id = ../../../../rxjs/scheduler/QueueAction.js\n// module chunks = common","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncScheduler_1 = require('./AsyncScheduler');\nvar QueueScheduler = (function (_super) {\n    __extends(QueueScheduler, _super);\n    function QueueScheduler() {\n        _super.apply(this, arguments);\n    }\n    return QueueScheduler;\n}(AsyncScheduler_1.AsyncScheduler));\nexports.QueueScheduler = QueueScheduler;\n//# sourceMappingURL=QueueScheduler.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/scheduler/QueueScheduler.js\n// module id = ../../../../rxjs/scheduler/QueueScheduler.js\n// module chunks = common","\"use strict\";\nvar QueueAction_1 = require('./QueueAction');\nvar QueueScheduler_1 = require('./QueueScheduler');\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * @examples <caption>Schedule recursively first, then do something</caption>\n *\n * Rx.Scheduler.queue.schedule(() => {\n *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n *\n *\n * @example <caption>Reschedule itself recursively</caption>\n *\n * Rx.Scheduler.queue.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n *\n *\n * @static true\n * @name queue\n * @owner Scheduler\n */\nexports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);\n//# sourceMappingURL=queue.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/scheduler/queue.js\n// module id = ../../../../rxjs/scheduler/queue.js\n// module chunks = common","\"use strict\";\nvar FastMap = (function () {\n    function FastMap() {\n        this.values = {};\n    }\n    FastMap.prototype.delete = function (key) {\n        this.values[key] = null;\n        return true;\n    };\n    FastMap.prototype.set = function (key, value) {\n        this.values[key] = value;\n        return this;\n    };\n    FastMap.prototype.get = function (key) {\n        return this.values[key];\n    };\n    FastMap.prototype.forEach = function (cb, thisArg) {\n        var values = this.values;\n        for (var key in values) {\n            if (values.hasOwnProperty(key) && values[key] !== null) {\n                cb.call(thisArg, values[key], key);\n            }\n        }\n    };\n    FastMap.prototype.clear = function () {\n        this.values = {};\n    };\n    return FastMap;\n}());\nexports.FastMap = FastMap;\n//# sourceMappingURL=FastMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/util/FastMap.js\n// module id = ../../../../rxjs/util/FastMap.js\n// module chunks = common","\"use strict\";\nvar root_1 = require('./root');\nvar MapPolyfill_1 = require('./MapPolyfill');\nexports.Map = root_1.root.Map || (function () { return MapPolyfill_1.MapPolyfill; })();\n//# sourceMappingURL=Map.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/util/Map.js\n// module id = ../../../../rxjs/util/Map.js\n// module chunks = common","\"use strict\";\nvar MapPolyfill = (function () {\n    function MapPolyfill() {\n        this.size = 0;\n        this._values = [];\n        this._keys = [];\n    }\n    MapPolyfill.prototype.get = function (key) {\n        var i = this._keys.indexOf(key);\n        return i === -1 ? undefined : this._values[i];\n    };\n    MapPolyfill.prototype.set = function (key, value) {\n        var i = this._keys.indexOf(key);\n        if (i === -1) {\n            this._keys.push(key);\n            this._values.push(value);\n            this.size++;\n        }\n        else {\n            this._values[i] = value;\n        }\n        return this;\n    };\n    MapPolyfill.prototype.delete = function (key) {\n        var i = this._keys.indexOf(key);\n        if (i === -1) {\n            return false;\n        }\n        this._values.splice(i, 1);\n        this._keys.splice(i, 1);\n        this.size--;\n        return true;\n    };\n    MapPolyfill.prototype.clear = function () {\n        this._keys.length = 0;\n        this._values.length = 0;\n        this.size = 0;\n    };\n    MapPolyfill.prototype.forEach = function (cb, thisArg) {\n        for (var i = 0; i < this.size; i++) {\n            cb.call(thisArg, this._values[i], this._keys[i]);\n        }\n    };\n    return MapPolyfill;\n}());\nexports.MapPolyfill = MapPolyfill;\n//# sourceMappingURL=MapPolyfill.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/util/MapPolyfill.js\n// module id = ../../../../rxjs/util/MapPolyfill.js\n// module chunks = common","\"use strict\";\n/* tslint:disable:no-empty */\nfunction noop() { }\nexports.noop = noop;\n//# sourceMappingURL=noop.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/remynguyen/Desktop/angular4/minimal/node_modules/rxjs/util/noop.js\n// module id = ../../../../rxjs/util/noop.js\n// module chunks = common"],"sourceRoot":"webpack:///"}